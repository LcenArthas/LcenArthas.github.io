
[{"content":" ","date":"2024-07-21","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":" 第 7 章 函数 # 分享一些在 Python 里编写函数的技巧。\n1. 仅限关键字参数 # 当调用参数较多（超过3个）的函数时，使用关键字参数模式可以大大提高代码的可读性。\n通过在参数列表中插入 * 符号，该符号后的所有参数都变成了“仅限关键字参数”（keyword-only argument）。调用的时候必须加入调用的参数名：\n#注意参数列表中的* 符号 def query_users(limit, offset, *, min_followers_count, include_profile): ... # 调用函数 \u0026gt;\u0026gt;\u0026gt; query_users(20, 0, 100, True) # 执行后报错： TypeError: query_users() takes 2 positional arguments but 4 were given # 正确的调用方式 \u0026gt;\u0026gt;\u0026gt; query_users(20, 0, min_followers_count=100, include_profile=True) 2. 返回 None 值 # 一般在“搜索”、“查询”这两个场景会使用 None 值进行返回。\n3. 给函数加上状态 —— 闭包 # 闭包是一种非常有用的工具，非常适合用来实现简单的有状态函数。\n闭包是一种允许函数访问已执行完成的其他函数里的私有变量的技术，是为函数增加状态的另一种方式。\n我感觉就是函数套函数，其实和下一章的装饰器有很大的联系。\n正常情况下，当Python完成一次函数执行后，本次使用的局部变量都会在调用结束后被回收，无法继续访问。但是，如果你使用下面这种“函数套函数”的方式，在外层函数执行结束后，返回内嵌函数，后者就可以继续访问前者的局部变量，形成了一个“闭包”结构，\ndef counter(): value = 0 def _counter(): # nonlocal 用来标注变量来自上层作用域，如不标明，内层函数将无法直接修改外层函数变量 nonlocal value value += 1 return value return _counter 其实上面的更好的方法时用类（class）实现， 只需要用类中初始化状态 __init__ 实现就好。\n抽象的概念 # 同一个函数代码应该处于同一抽象级别内。\n详见书中 P196 - P203\n第 8 章 装饰器 # 一些在 Python 中编写装饰器的技巧，以及几个用于编写装饰器的常见工具。\n1. 装饰器基础 # 装饰器是一种通过包装目标函数来修改其行为的特殊高阶函数，绝大多数装饰器是利用函数的 闭包原理实现的。\n1. 无参数装饰器 # def timer(func): \u0026#34;\u0026#34;\u0026#34;装饰器：打印函数耗时\u0026#34;\u0026#34;\u0026#34; def decorated(*args, **kwargs): st = time.perf_counter() ret = func(*args, **kwargs) print(\u0026#39;time cost: {} seconds\u0026#39;.format(time.perf_counter() - st)) return ret return decorated 在写装饰器时，我一般把 decorated 叫作 “包装函数”。\n2. 有参数装饰器 # def timer(print_args=False): \u0026#34;\u0026#34;\u0026#34;装饰器：打印函数耗时 :param print_args: 是否打印方法名和参数，默认为 False \u0026#34;\u0026#34;\u0026#34; def decorator(func): def wrapper(*args, **kwargs): st = time.perf_counter() ret = func(*args, **kwargs) if print_args: print(f\u0026#39;\u0026#34;{func.__name__}\u0026#34;, args: {args}, kwargs: {kwargs}\u0026#39;) print(\u0026#39;time cost: {} seconds\u0026#39;.format(time.perf_counter() - st)) return ret return wrapper return decorator 在应用有参数装饰器时，一共要做两次函数调用，所以装饰器总共得包含三层嵌套函数。\n2. 使用 functools.wraps() 修饰包装函数。 # 在装饰器包装目标函数的过程中，常会出现一些副作用，其中一种是丢失函数元数据。\n会出现下面的情况：\n\u0026gt;\u0026gt;\u0026gt; random_sleep.__name__ \u0026#39;decorated\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(random_sleep.__doc__) None 或者饰器给函数追加的属性找不到了。\n要解决这个问题，我们需要在装饰器内包装函数时，保留原始函数的额外属性。 而 functools 模块下的 wraps() 函数正好可以完成这件事情。使用 wraps()，装饰器只需要做一点儿改动：\nfrom functools import wraps def timer(func): @wraps(func) def decorated(*args, **kwargs): ... return decorated 添加 @wraps(wrapped) 来装饰 decorated 函数后，wraps() 首先会基于原函数 func 来更新包装函数 decorated 的名称、文档等内置属性，之后会将 func 的所有额外属性赋值到 decorated 上。\n3. 用类来实现装饰器 # 判断对象是否能通过装饰器（@decorator）的形式使用只有一条判断标准，那就是 decorator 是不是一个可调用的对象。\n自然函数是可调用的对象。\n\u0026gt;\u0026gt;\u0026gt; class Foo: ... pass ... \u0026gt;\u0026gt;\u0026gt; callable(Foo) True # 使用callable()内置函数可以判断某个对象是否可调用。 类（class）也可以是调用对象，前提是一个类中实现了 __call__ 魔法方法，那么他的实例也会变成调用对象。\n\u0026gt;\u0026gt;\u0026gt; class Foo: ... def __call__(self, name): ... print(f\u0026#39;Hello, {name}\u0026#39;) ... \u0026gt;\u0026gt;\u0026gt; foo = Foo() \u0026gt;\u0026gt;\u0026gt; callable(foo) True \u0026gt;\u0026gt;\u0026gt; foo(\u0026#39;World\u0026#39;) Hello, World 1. 函数替换装饰器 # 这种技术最适合用来实现接收参数的装饰器。\nclass timer: \u0026#34;\u0026#34;\u0026#34;装饰器：打印函数耗时 :param print_args: 是否打印方法名和参数，默认为 False \u0026#34;\u0026#34;\u0026#34; def __init__(self, print_args): self.print_args = print_args def __call__(self, func): @wraps(func) def decorated(*args, **kwargs): st = time.perf_counter() ret = func(*args, **kwargs) if self.print_args: print(f\u0026#39;\u0026#34;{func.__name__}\u0026#34;, args: {args}, kwargs: {kwargs}\u0026#39;) print(\u0026#39;time cost: {} seconds\u0026#39;.format(time.perf_counter() - st)) return ret return decorated （1）第一次调用：_deco = timer(print_args=True) 实际上是在初始化一个 timer 实例。\n（2）第二次调用：func = _deco(func) 是在调用 timer 实例，触发 __call__ 方法。\n2. “实例替换”装饰器 # 无参数装饰器 DelayedStart\nclass DelayedStart: \u0026#34;\u0026#34;\u0026#34;在执行被装饰函数前，等待 1 秒钟\u0026#34;\u0026#34;\u0026#34; def __init__(self, func): update_wrapper(self, func) ➊ self.func = func def __call__(self, *args, **kwargs): ➋ print(f\u0026#39;Wait for 1 second before starting...\u0026#39;) time.sleep（1） return self.func(*args, **kwargs) def eager_call(self, *args, **kwargs): ➌ \u0026#34;\u0026#34;\u0026#34;跳过等待，立刻执行被装饰函数\u0026#34;\u0026#34;\u0026#34; print(\u0026#39;Call without delay\u0026#39;) return self.func(*args, **kwargs) ❶ update_wrapper与前面的wraps一样，都是把被包装函数的元数据更新到包装者（在这里是DelayedStart实例）上。 ❷ 通过实现 __call__ 方法，让 DelayedStart 的实例变得可调用，以此模拟函数的调用行为。 ❸ 为装饰器类定义额外方法，提供更多样化的接口。 \u0026gt;\u0026gt;\u0026gt; @DelayedStart ... def hello(): ... print(\u0026#34;Hello, World.\u0026#34;) \u0026gt;\u0026gt;\u0026gt; hello \u0026lt;__main__.DelayedStart object at 0x100b71130\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(hello) \u0026lt;class \u0026#39;__main__.DelayedStart\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; hello.__name__➊ \u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; hello() ➋ Wait for 1 second before starting... Hello, World. \u0026gt;\u0026gt;\u0026gt; hello.eager_call() ➌ Call without delay Hello, World. ❶ 被装饰的hello函数已经变成了装饰器类DelayedStart的实例，但是因为update_wrapper的作用，这个实例仍然保留了被装饰函数的元数据。 ❷ 此时触发的其实是装饰器类实例的__call__方法。 ❸ 使用额外的eager_call接口调用函数。 带参数装饰器 DelayedStart\nclass DelayedStart: \u0026#34;\u0026#34;\u0026#34;在执行被装饰函数前，等待一段时间 :param func: 被装饰的函数 :param duration: 需要等待的秒数 \u0026#34;\u0026#34;\u0026#34; def __init__(self, func, *, duration=1): ➊ update_wrapper(self, func) self.func = func self.duration = duration def __call__(self, *args, **kwargs): print(f\u0026#39;Wait for {self.duration} second before starting...\u0026#39;) time.sleep(self.duration) return self.func(*args, **kwargs) def eager_call(self, *args, **kwargs): ... def delayed_start(**kwargs): \u0026#34;\u0026#34;\u0026#34;装饰器：推迟某个函数的执行\u0026#34;\u0026#34;\u0026#34; return functools.partial(DelayedStart, **kwargs) ➋ ❶ 把 func 参数以外的其他参数都定义为“仅限关键字参数”，从而更好地区分原始函数与装饰器的其他参数。 ❷ 通过 partial 构建一个新的可调用对象，这个对象接收的唯一参数是待装饰函数 func，因此可以用作装饰器。 delayed_start 这个函数必不可少，实例化这个 DelayedStart 类，便于接受 func 参数。\n@delayed_start(duration=2) def hello(): print(\u0026#34;Hello, World.\u0026#34;) 相比传统做法，用类来实现装饰器（实例替换）的主要优势在于，你可以更方便地管理装饰器的内部状态，同时也可以更自然地为被装饰对象追加额外的方法和属性。\n4. 装饰器设计技巧 # 装饰器里应该只有一层浅浅的包装代码，要把核心逻辑放在其他函数与类中。\n第 9 章 面对对象编程 ⭐ # 在 Python 里，万物皆对象。\n1. 私有属性 # 在 Python 里，所有的类属性和方法默认都是公开的，不过你可以通过添加双下划线前缀 __ 的方式把它们标示为私有。\nclass Foo: def __init__(self): self.__bar = \u0026#39;baz\u0026#39; # 上面代码中 Foo 类的 bar 就是一个私有属性，如果你尝试从外部访问它，程序就会抛出异常 \u0026gt;\u0026gt;\u0026gt; foo = Foo() \u0026gt;\u0026gt;\u0026gt; foo.__bar AttributeError: \u0026#39;Foo\u0026#39; object has no attribute \u0026#39;__bar\u0026#39; 注意：Python里的私有只是一个“君子协议”。你可以使用 _{class}__{var} 这个别名来访问。\n\u0026gt;\u0026gt;\u0026gt; foo._Foo__bar \u0026#39;baz\u0026#39; 2. 实例所有内容都在字典内 # 一个类实例的所有成员，其实都保存在了一个名为 __dict__ 的字典属性中。\nclass Person: def __init__(self, name, age): self.name = name self.age = age def say(self): print(f\u0026#34;Hi, My name is {self.name}, I\u0026#39;m {self.age}\u0026#34;) 查看 __dict__ ：\n\u0026gt;\u0026gt;\u0026gt; p = Person(\u0026#39;raymond\u0026#39;, 30) \u0026gt;\u0026gt;\u0026gt; p.__dict__➊ {\u0026#39;name\u0026#39;: \u0026#39;raymond\u0026#39;, \u0026#39;age\u0026#39;: 30} \u0026gt;\u0026gt;\u0026gt; Person.__dict__➋ mappingproxy({\u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__init__\u0026#39;: \u0026lt;function Person.__init__at 0x109611ca0\u0026gt;, \u0026#39;say\u0026#39;: \u0026lt;function Person.say at 0x109611d30\u0026gt;, \u0026#39;__dict__\u0026#39;: \u0026lt;attribute \u0026#39;__dict__\u0026#39; of \u0026#39;Person\u0026#39; objects\u0026gt;, \u0026#39;__weakref__\u0026#39;: \u0026lt;attribute \u0026#39;__weakref__\u0026#39; of \u0026#39;Person\u0026#39; objects\u0026gt;, \u0026#39;__doc__\u0026#39;: None}) ❶ 实例的 __dict__ 里，保存着当前实例的所有数据。\n❷ 类的 __dict__ 里，保存着类的文档、方法等所有数据。\n3. 内置类方法装饰器 # 1. @classmethod 装饰器（类方法） # 普通方法无法通过类来调用，但你可以用 @classmethod装饰器 定义一种特殊的方法：类方法（class method），它属于类但是无须实例化也可调用。\nclass Duck: ... @classmethod def create_random(cls): ➊ \u0026#34;\u0026#34;\u0026#34;创建一只随机颜色的鸭子\u0026#34;\u0026#34;\u0026#34; color = random.choice([\u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;gray\u0026#39;]) return cls(color=color) ❶ 普通方法接收类实例（self）作为参数，但类方法的第一个参数是类本身，通常使用名字 cls。\n调用效果：\n\u0026gt;\u0026gt;\u0026gt; d = Duck.create_random() \u0026gt;\u0026gt;\u0026gt; d.quack() Hi, I\u0026#39;m a white duck! \u0026gt;\u0026gt;\u0026gt; d.create_random() ➊ \u0026lt;__main__.Duck object at 0x10f8f2f40\u0026gt; 2. @staticmethod 静态方法 # 如果某个方法不需要使用当前实例里的任何内容，那可以使用 @staticmethod 来定义一个静态方法。\n其实和外部一个普通函数类似。但是静态方法可以被子类继承和重写。\nclass Cat: def __init__(self, name): self.name = name def say(self): sound = self.get_sound() print(f\u0026#39;{self.name}: {sound}...\u0026#39;) @staticmethod def get_sound(): ➊ repeats = random.randrange(1, 10) return \u0026#39; \u0026#39;.join([\u0026#39;Meow\u0026#39;] * repeats) ❶ 静态方法不接收当前实例作为第一个位置参数。\n3. @preperty 属性装饰器 # 在一个类里，属性和方法有着不同的职责：属性代表状态，方法代表行为。\n使用 @property装饰器，你可以把方法变成一个虚拟属性，然后像使用普通属性一样使用它：\nclass FilePath: ... @property def basename(self): \u0026#34;\u0026#34;\u0026#34;获取文件名\u0026#34;\u0026#34;\u0026#34; return self.path.rsplit(os.sep, 1)[-1] 调用效果如下：\n\u0026gt;\u0026gt;\u0026gt; p = FilePath(\u0026#39;/tmp/foo.py\u0026#39;) \u0026gt;\u0026gt;\u0026gt; p.basename \u0026#39;foo.py\u0026#39; @property 除了可以定义属性的读取逻辑外，还支持自定义写入和删除逻辑：\nclass FilePath: ... @property def basename(self): \u0026#34;\u0026#34;\u0026#34;获取文件名\u0026#34;\u0026#34;\u0026#34; return self.path.rsplit(os.sep, 1)[-1] @basename.setter ➊ def basename(self, name): ➋ \u0026#34;\u0026#34;\u0026#34;修改当前路径里的文件名部分\u0026#34;\u0026#34;\u0026#34; new_path = self.path.rsplit(os.sep, 1)[:-1] + [name] self.path = os.sep.join(new_path) @basename.deleter def basename(self): ➌ raise RuntimeError(\u0026#39;Can not delete basename!\u0026#39;) ❶ 经过 @property 的装饰以后，basename已经从一个普通方法变成了 property 对象，因此这里可以使用 basename.setter。\n❷ 定义 setter 方法，该方法会在对属性赋值时被调用。\n❸ 定义 deleter 方法，该方法会在删除属性时被调用。\n调用效果如下：\n\u0026gt;\u0026gt;\u0026gt; p = FilePath(\u0026#39;/tmp/foo.py\u0026#39;) \u0026gt;\u0026gt;\u0026gt; p.basename = \u0026#39;bar.txt\u0026#39; # 触发 setter 方法 \u0026gt;\u0026gt;\u0026gt; p.path \u0026#39;/tmp/bar.txt\u0026#39; \u0026gt;\u0026gt;\u0026gt; del p.basename # 触发 deleter 方法 RuntimeError: Can not delete basename! 4. 鸭子类型 # “鸭子类型”是 Python 语言最鲜明的特点之一，在该风格下，一般不做任何严格的类型检查。\n在鸭子类型中，关注点在于对象的行为（方法/函数）能做什么；而不是关注对象所属的类型。\n在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的\u0026quot;走\u0026quot;和\u0026quot;叫\u0026quot;方法。\n缺点就是：缺乏标准，不需要严格的类型校验；鸭子类型使用的前提是需要良好的文档支持，不然会让代码变得很混乱，如果没有良好的文档及说明，有可能会导致你的“鸭子”不是我的“鹅”了。\n5. 抽象类 # 抽象类是一种特殊的类。\n在Python中抽象类只能被继承，不能被实例化。\n继承于抽象基类的子类必须给出所有抽象方法和属性的具体实现，才可以进行正常的实例化。\n1. 抽象类的作用 # 在面向对象思想中，抽象基类一般用于统一接口，使得业务代码可以不随着实现得改变而改变（因为抽象基类已经确定了接口）（下两章的内容）。例如，如果把“动物”作为一个抽象类，那么它可以拥有诸如“吃”或“叫”的方法。但是，抽象类本身可以不实现方法，只需要定义框架，因为不同的子类（例如“猫”和“狗”）对方法的实现可能是不同的。既然这样，为什么不直接定义子类呢？是因为当有了抽象类后，你可以这样说“我养了一只\u0026lt;动物\u0026gt;，它这样\u0026rsquo;\u0026lt;动物\u0026gt;.吃\u0026rsquo;, 那样\u0026rsquo;\u0026lt;动物\u0026gt;.叫\u0026rsquo;“。只要传递的是”动物“的子类，那么这句话就是正确的且不需要修改的，因为”动物“这个抽象类已经把接口形式定义好了。抽象类的另一个使用方式是通过类型检查来确定某些接口是否存在，例如，“如果它是一只动物，那么它既能\u0026rsquo;吃\u0026rsquo;，又能\u0026rsquo;叫\u0026rsquo;”。\n简单来说，在不同的模块中通过抽象基类来调用，可以用最精简的方式展示出代码之间的逻辑关系，让模块之间的依赖清晰简单。\n抽象类的编程，让每个人可以关注当前抽象类的方法和描述，而不需要考虑过多的实现细节，这对协同开发有很大意义，也让代码可读性更高。\n2. 定义抽象类 # 在 Python 中，抽象基类由标准库 abc 支持。abc 中提供了两个核心的用于抽象基类的类：ABCMeta 和 ABC，前者用于自定义抽象基类时指定为元类，而后者则提供了可以直接继承来使用的抽象基类。\n# 导入抽象类需要用到的库 from abc import ABCMeta, abstractmethod class Person(metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;使用元类（模板类）\u0026#34;\u0026#34;\u0026#34; pname = \u0026#34;这是Person抽象类\u0026#34; # 可以定义属性 # 定义抽象方法，抽象方法不需要方法体 # 需要在方法前加@abstractmethod装饰器 @abstractmethod def run(self): pass # 不需要写方法体 @classmethod # 可以定义类方法 def eat(cls): print(\u0026#34;在吃东西啊\u0026#34;) @staticmethod def drink(): # 可以定义静态方法 print(\u0026#34;在喝东西啊\u0026#34;) def sleep(self): # 可以定义普通方法 print(\u0026#34;在睡觉啊\u0026#34;) 继承了抽象类，必须重写抽象类中的抽象方法 @abstractmethod装饰器，否则无法实例化对象，并抛异常。\n类 ABC 是 abc 模块提供的用于直接继承的抽象基类，也就是说，上面例子中所有的 metaclass=abc.ABCMeta 都可以直接替换为 abc.ABC：\nimport abc class Person(abc.ABC): \u0026#34;\u0026#34;\u0026#34;使用元类（模板类）\u0026#34;\u0026#34;\u0026#34; pname = \u0026#34;这是Person抽象类\u0026#34; # 可以定义属性 @abstractmethod def run(self): pass # 不需要写方法体 抽象类是软件开发中一个非常重要的概念，通过定义抽象类，我们可以约定子类必需实现的方法。当我们一个类有几十上百个方法时，用抽象方法来防止子类漏掉某些方法是非常方便的做法。\n6. 面向对象设计 # 继承提供了相当强大的代码复用机制，但同时也带来了非常紧密的耦合关系。\n错误使用继承容易导致代码失控。\n对事物的行为而不是事物本身建模，更容易孵化出好的面向对象设计。\n在创建继承关系时应当谨慎。用组合来替代继承有时是更好的做法。\n7. 有序组织你的类方法 # 在组织类方法时，我们应该关注使用者的诉求，把他们最想知道的内容放在前面，把他们不那么关心的内容放在后面。\n作为惯例，__init__ 实例化方法应该总是放在类的最前面，__new__ 方法同理。\n公有方法应该放在类的前面，因为它们是其他模块调用类的入口，是类的门面，也是所有人最关心的内容。\n以 _ 开头的私有方法，大部分是类自身的实现细节，应该放在靠后的位置。\n以 __ 开头的魔法方法比较特殊，通常按照方法的重要程度来决定它们的位置。比如一个迭代器类的__iter__ 方法应该放在非常靠前的位置，因为它是构成类接口的重要方法。\n最后一点，当你从上往下阅读类时，所有方法的抽象级别应该是不断降低的，就好像阅读一篇新闻一样，第一段是新闻的概要，之后才会描述细节。\n第 10 章 面向对象的设计原则（上） # SOLID 原则的雏形来自 Robert C. Martin（Bob大叔）于2000年发表的一篇文章。\nSOLID 单词里的5个字母，分别代表5条设计原则。\nS：single responsibility principle（单一职责原则，SRP）。（类的指责有关） O：open-closed principle（开放–关闭原则，OCP）。（类的修改与扩展） L：Liskov substitution principle（里式替换原则，LSP）。(和继承有关) I：interface segregation principle（接口隔离原则，ISP）。（和编写接口中更精确的抽象） D：dependency inversion principle（依赖倒置原则，DIP）。（和编写接口抽象有关） 1. 类型注释基础 # 下面是添加了类型注解后的代码：\nfrom typing import List class Duck: def __init__(self, color: str): ➊ self.color = color def quack(self) -\u0026gt; None: ➋ print(f\u0026#34;Hi, I\u0026#39;m a {self.color} duck!\u0026#34;) def create_random_ducks(number: int) -\u0026gt; List[Duck]: ➌ ducks: List[Duck] = [] ➍ for _ in number: color = random.choice([\u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;gray\u0026#39;]) ➎ ducks.append(Duck(color=color)) return ducks ❶ 给函数参数加上类型注解。\n❷ 通过-\u0026gt;给返回值加上类型注解。\n❸ 你可以用typing模块的特殊对象List来标注列表成员的具体类型，注意，这里用的是[]符号，而不是()。\n❹ 声明变量时，也可以为其加上类型注解。\n❺ 类型注解是可选的，非常自由，比如这里的 color 变量就没加类型注解。\n2. SRP: 单一职责原则 # SRP认为：一个类应该仅有一个被修改的理由。换句话说，每个类都应该只承担一种职责。\n单个类承担的职责越多，就意味着这个类越复杂，越难维护。\n怎么修改脚本才能让它符合 SRP 呢？\n办法有很多，其中最传统的就是把大类拆分为小类。\n函数同样可以做到“单一职责。将某个职责拆分为新函数是一个具有 Python 特色的解决方案。它虽然没有那么“面向对象”，却非常实用，甚至在许多场景下比编写类更简单、更高效。\n3. OCP：开放-关闭原则 # 该原则认为：类应该对扩展开放，对修改封闭。换句话说，你可以在不修改某个类的前提下，扩展它的行为。(本身不变，但是易于扩展)\n1. 通过继承改造代码 # 继承提供了强大的代码复用能力。继承允许我们用一种新增子类而不是修改原有类的方式来扩展程序的行为，这恰好符合OCP。\n而要做到有效地扩展，关键点在于先找到父类中不稳定、会变动的内容。只有将这部分变化封装成方法（或属性），子类才能通过继承重写这部分行为。\n通过继承践行OCP 2. 使用组合与依赖注入 # 除了继承外，我们还可以采用另一种思路：组合（composition）。更具体地说，使用基于组合思想的依赖注入（dependency injection）技术。\n依赖注入允许我们在创建对象时，将业务逻辑中易变的部分（常被称为“算法”）通过初始化参数注入对象里，最终利用多态特性达到“不改代码来扩展类”的效果。\n通过依赖注入实现OCP 所以我必须编写一个抽象类，以此满足类型注解的需求。\n3. 使用数据驱动 # 它的核心思想是：将经常变动的部分以数据的方式抽离出来，当需求变化时，只改动数据，代码逻辑可以保持不动。\n依赖注入抽离的通常是类，而数据驱动抽离的是纯粹的数据。\n优点：使用数据驱动的代码明显更简洁，因为它不需要定义任何额外的类。 缺点：它的可定制性不如其他两种方式。 影响每种方案可定制性的根本原因在于，各方案所处的抽象级别不一样。\n第 11 章 面向对象的设计原则（下） # 1. LSP：里式替换原则 # LSP认为，所有子类（派生类）对象应该可以任意替代父类（基类）对象使用，且不会破坏程序原本的功能。\n1. 违反 LSP 的几种常见方式 # 子类抛出了父类所不认识的异常类型； 子类的方法返回值类型与父类不同，并且该类型不是父类返回值类型的子类； 子类的方法参数与父类不同，并且参数要求没有变得更宽松（可选参数）、同名参数没有更抽象。 2. 调整方式 # 有时你得在父类中引入新的异常类型； 有时你得尝试用组合替代继承； 有时你需要调整子类的方法参数。 2. DIP：依赖倒置原则 # DIP是一条与依赖关系相关的原则。它认为：高层模块不应该依赖低层模块，二者都应该依赖抽象。 （这一章会涉及之前讲的抽象类）\nDIP 里的“抽象”特指编程语言里的一类特殊对象，这类对象只声明一些公开的 API，并不提供任何具体实现。 （和抽象类中的抽象函数 @abstractmethod 理念一致）\nfrom abc import ABC, abstractmethod class Drawable(ABC): @abstractmethod def draw(self): ... 设计抽象，其主要任务是确定这个抽象的职责与边界。\nSi​teSourceGrouper和RemoteHNWebPage都依赖抽象HNWebPage 当你习惯了DIP以后，会发现抽象不仅仅是一种编程手法，更是一种思考问题的特殊方式。只要愿意动脑子，你可以在代码的任何角落里都硬挤出一层额外抽象。\n事实是，抽象的好处显而易见：它解耦了模块间的依赖关系，让代码变得更灵活。但抽象同时也带来了额外的编码与理解成本。\n3. ISP：接口隔离原则 # ISP对如何使用接口提出了要求：客户（cl​ient）不应该依赖任何它不使用的方法。\nISP里的“客户”不是使用软件的客户，而是接口的使用方——客户模块，也就是依赖接口的高层模块。\n1. 违反 ISP # 页面归档功能类关系图 问题1：Si​teSourceGrouper 类依赖了 HNWebPage，但是并不使用后者的 get_size()、get_generated_at()方法。 问题2：LocalHNWebPage 类为了实现 HNWebPage 抽象，需要“退化” get_generated_at() 方法。 2. 拆分接口 # 让客户（调用方）来驱动协议设计。在现在的程序里，HNWebPage接口共有两个客户。\nHNWebPage接口共有两个客户。\nSi​teSourceGrouper：按域名来源统计，依赖 get_text()。 Si​teAchiever：页面归档程序，依赖 get_text()、get_size() 和 get_generated_at()。 实施接口隔离后的结果 第 12 章 数据模型与描述符 # P324 \u0026ndash; P355\n第 13 章 开发大型项目 # 本章主要介绍常用的代码格式化工具、常用的测试工具和实用的单元测试技巧。\n1. 格式化检查工具 # 1. f​lake8 # 利用 f​lake8，你可以轻松检查代码是否遵循了 PEP 8 规范。\nf​lake8的PEP 8检查功能，并非由f​lake8自己实现，而是主要由集成在f​lake8里的另一个Linter工具pycodestyle提供。\n2. isort # PEP 8认为，一个源码文件内的所有import语句，都应该依照以下规则分为三组：\n导入Python标准库包的import语句； 导入相关联的第三方包的import语句； 与当前应用（或当前库）相关的import语句。 借助 isort，我们不用手动进行任何分组，它会帮我们自动做好这些事。\n3. black # black 是一个更为严格的格式化工具。\nblack用起来很简单，只要执行black {f​i​lename}命令即可。\n4. mypy # 为了在程序执行前就找出由类型导致的潜在bug，提升代码正确性，人们为Python开发了不少静态类型检查工具，其中mypy最为流行。\n在大型项目中，类型注解与mypy的组合能大大提升项目代码的可读性与正确性。给代码写上类型注解后，函数参数与变量的类型会变得更明确，人们在阅读代码时更不容易感到困惑。再配合mypy做静态检查，可以轻松找出藏在代码里的许多类型问题。\n1. 单元测试 # 1. unittest # uni​t​test 是标准库里的单元测试模块，使用方便，无须额外安装。\nimport unittest class TestStringUpper(unittest.TestCase): def test_normal(self): self.assertEqual(\u0026#39;foo\u0026#39;.upper(), \u0026#39;FOO\u0026#39;) if __name__== \u0026#39;__main__\u0026#39;: unittest.main() 用 uni​t​test 编写测试用例的第一步，是创建一个继承 uni​t​test.TestCase 的子类，然后编写许多以 test 开头的测试方法。\n在方法内部，通过调用一些以 assert 开头的方法来进行测试断言，如下所示。\nsel​f.assertEqual(x, y)：断言x和y必须相等。 sel​f.assertTrue(x)：断言x必须为布尔真。 sel​f.assertGreaterEqual(x, y)：断言x必须大于等于y。 在 uni​t​test 包内，这样的 assert{X} 方法超过30个。\n2. pytest # pytest是一个开源的第三方单元测试框架。\ndef string_upper(s: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;将某个字符串里的所有英文字母由小写转换为大写\u0026#34;\u0026#34;\u0026#34; chars = [] for ch in s: # 32 是小写字母与大写字母在ASCII 码表中的距离 chars.append(chr(ord(ch) - 32)) return \u0026#39;\u0026#39;.join(chars) 为了测试函数的功能，我用pytest写了一份单元测试：\n文件：test_string_ut​i​ls.py\nfrom string_utils import string_upper def test_string_upper(): assert string_upper(\u0026#39;foo\u0026#39;) == \u0026#39;FOO\u0026#39; 用 pytest 执行上面的测试文件，会输出以下结果：\n$ pytest test_string_utils.py ===================== test session starts ===================== platform darwin -- Python 3.8.1, pytest-6.2.2 rootdir: /python_craftman/ collected 1 item test_string_utils.py . [100%] ====================== 1 passed in 0.01s ====================== 用 parametrize 编写参数化测试\n在单元测试领域，有一种常用的编写测试代码的技术：表驱动测试（table-driven test​ing）​。\nimport pytest from string_utils import string_upper @pytest.mark.parametrize( \u0026#39;s,expected\u0026#39;, ➊ [ (\u0026#39;foo\u0026#39;, \u0026#39;FOO\u0026#39;), ➋ (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), (\u0026#39;foo BAR\u0026#39;, \u0026#39;FOO BAR\u0026#39;), ], ) def test_string_upper(s, expected): ➌ assert string_upper(s) == expected ➍ ❶ 用逗号分隔的参数名列表，也可以理解为数据表每一列字段的名称; ❷ 数据表的每行数据通过元组定义，元组成员与参数名一一对应; ❸ 在测试函数的参数部分，按parametrize定义的字段名，增加对应参数; ❹ 在测试函数内部，用参数替换静态测试数据。 pytest 的功能非常强大，本节只对它做了最基本的介绍。如果你想在项目里使用pytest，可以阅读它的官方文档，里面的内容非常详细。\n写在最后 # 除了本章提到的这些内容以外，我还建议你继续学习一些敏捷编程、领域驱动设计、整洁架构方面的内容。从我的个人经历来看，这些知识对于大型项目开发有很好的启发作用。\n无论如何，永远不要停止学习。\n","date":"2024-07-21","externalUrl":null,"permalink":"/booknote/python%E5%B7%A5%E5%8C%A0%E4%B8%8B/","section":"读书","summary":"","title":"《Pyhotn工匠——案例、技巧与工程实践》（下）","type":"booknote"},{"content":"","date":"2024-07-21","externalUrl":null,"permalink":"/series/python%E5%B7%A5%E5%8C%A0/","section":"Series","summary":"","title":"《Python工匠》","type":"series"},{"content":"","date":"2024-07-21","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"2024-07-21","externalUrl":null,"permalink":"/tags/python-%E5%9B%BE%E4%B9%A6/","section":"Tags","summary":"","title":"Python 图书","type":"tags"},{"content":"","date":"2024-07-21","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024-07-21","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-07-21","externalUrl":null,"permalink":"/booknote/","section":"读书","summary":"","title":"读书","type":"booknote"},{"content":"","date":"2024-07-21","externalUrl":null,"permalink":"/tags/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D/","section":"Tags","summary":"","title":"技术书籍","type":"tags"},{"content":" 适合进阶 Python。本书类似 Python Cookbook 或者 Fluent Python，但是更偏重工程实践，不止于概念 Tricks 本身，更在乎如何用这些技术的最佳实践构建出可靠、优雅和 Pythonic 的工程。由于是新书，里面的概念还是比较新，type hints与mypy的类型检查方案是有的，但是似乎没有对 PEP 585 进行修订。\n—— 豆瓣网友@歧路花火 2022-05-20 18:18:42\n第 1 章 变量和注释 # 在一段代码中，变量和注释是最接近自然语言的东西。因此好的变量名、简明扼要的注释，都可以显著提高代码的质量。\n这一章主要是介绍了常用的变量命名的原则，介绍了编程写代码的注释的集中方式。\n1. 变量的命名使用原则 # 1. 星号表达式 # 可以使用星号表达式（*variables）作为变量名，他便会贪婪地捕获多个值对象，并将捕获到的内容作为列表赋值给 variables 。\n例如：\n\u0026gt;\u0026gt;\u0026gt; data = [\u0026#39;piglei\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;, 100] \u0026gt;\u0026gt;\u0026gt; username, *fruits, score = data \u0026gt;\u0026gt;\u0026gt; username \u0026#39;piglei\u0026#39; \u0026gt;\u0026gt;\u0026gt; fruits [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;] \u0026gt;\u0026gt;\u0026gt; score 100 有时候可以配合单下划线 _ 使用，通常可以在想要忽视某些变量时候使用，\n例如：\n# 忽略展开时的第二个变量 \u0026gt;\u0026gt;\u0026gt; author, _ = usernames # 忽略第一个和最后一个变量之间的所有变量 \u0026gt;\u0026gt;\u0026gt; username, *_, score = data 2. 给变量注明类型 # 因为 Python 是动态类型语言，使用变量时不需要做任何的类型声明。但是为了代码的可读性，还是建议使用类型注解（Python3.5+版本）。\n要使用类型注解，只需要在变量后添加类型，并用冒号隔开即可，比如 func(value: str) 表示函数的 value 参数为字符串类型.\n3. 变量命名原则 # 变量起名要遵循 PEP8 原则。\n尽量给变量起描述性强的名字，同时变量名尽量短。\n其中有一类超短命名，使用一两个字母来命名，下面是一些约定俗成的变量名字：\n数组索引三剑客 i、j、k 某个整数 n 某个字符串 s 某个异常 e 文件对象 fp 同一段代码中尽量避免多个相似的变量名，比如同时使用 users，users1，uesrs2 这种序列。\n4. 保持变量的一致性 # 使用变量时，需要保证他在两方面的一致性，名字一致性和类型一致性。\n名字一致性是指在同一个项目（或者模块、函数）中，对一类事物的称呼不要变来变去。\n类型一致性则是指不要把同一个变量重复指向不同类型的值。举例：\ndef foo(): # users 本身是一个 Dict users = {\u0026#39;data\u0026#39;: [\u0026#39;piglei\u0026#39;, \u0026#39;raymond\u0026#39;]} ... # users 这个名字真不错！尝试复用它，把它变成 List 类型 users = [] ... 在 foo() 函数的作用域内，users 变量被使用了两次：第一次指向字典，第二次则变成了列表。\n2. 注释的注意事项 # 1. 接口注释 # 在编写接口文档时，我们应该站在函数设计者的角度，着重描述函数的功能、参数说明等。\n而函数自身的实现细节——比如调用了哪个第三方模块、为啥有性能问题等，都不用放在接口文档里。\n对于 resize_image() 函数来说，文档里提供以下内容就足够了：\ndef resize_image(image, size): \u0026#34;\u0026#34;\u0026#34;将图片缩放为指定尺寸，并返回新的图片。 注意：当文件超过 5MB 时，请使用 resize_big_image() :param image: 图片文件对象 :param size: 包含宽高的元组：（width, height） :return: 新图片对象 \u0026#34;\u0026#34;\u0026#34; 2. 空行也是一种 “注释” # 在写代码时，我们可以适当的在代码中插入空行，把代码按不同的逻辑块分隔开来，这样能有效提高代码可读性。\n3. 先写注释，后写代码 # 主要是为了避免写完代码之后，对待注释草草应付了事。\n第 2 章 数值与字符串 # 这一章主要是介绍了 Python 中数值的基础知识和字符串的使用技巧。\n1. 数值的基础知识 # 1. decimal 模块 # Python 的浮点数有精度问题，可以使用 decimal.Decimal 对象来代替普通浮点数，做精确计算。例如：\n\u0026gt;\u0026gt;\u0026gt; from decimal import Decimal # 注意：这里的\u0026#39;0.1\u0026#39;和\u0026#39;0.2\u0026#39; 必须是字符串 \u0026gt;\u0026gt;\u0026gt; Decimal(\u0026#39;0.1\u0026#39;) + Decimal(\u0026#39;0.2\u0026#39;) Decimal(\u0026#39;0.3\u0026#39;) 在使用 Decimal 的过程中，需要注意：必须使用字符串来表示数字。 2. 字符串的使用 # 1. 字符串的内置方法 # 记录了字符串中常用和不常用的方法：\nreversed，反转字符串 \u0026gt;\u0026gt;\u0026gt; s = \u0026#39;Hello, world!\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(reversed(s)) \u0026#39;!dlrow ,olleH\u0026#39; reversed 会返回一个可迭代对象，通过字符串的 .join 方法可以将它转换为字符串。\n.startswith()，检查字符串是否以指定的前缀开始。它返回布尔值 True 或 False。 text = \u0026#34;Hello, world!\u0026#34; print(text.startswith(\u0026#34;Hello\u0026#34;)) # 输出: True print(text.startswith(\u0026#34;world\u0026#34;)) # 输出: False .partation()，用于在第一次出现指定 分隔符 的位置将字符串分成三部分：\n分隔符前的部分、分隔符本身、和分隔符后的部分。它返回一个包含这三部分的元组。 text = \u0026#34;Hello, world!\u0026#34; result = text.partition(\u0026#34;, \u0026#34;) print(result) # 输出: (\u0026#39;Hello\u0026#39;, \u0026#39;, \u0026#39;, \u0026#39;world!\u0026#39;) 和 .split() 的区别，.partition() 返回了一个三元素的元组，而 .split() 返回了一个列表，并且列表中不包含分隔符。\n.translate(table)，按规则一次性替换多个字符，使用它比调用多次 replace 方法更快也更简单。 \u0026gt;\u0026gt;\u0026gt; s = \u0026#39;明明是中文,却使用了英文标点.\u0026#39; # 创建替换规则表：\u0026#39;,\u0026#39; -\u0026gt; \u0026#39;，\u0026#39;, \u0026#39;.\u0026#39; -\u0026gt; \u0026#39;。\u0026#39; \u0026gt;\u0026gt;\u0026gt; table = s.maketrans(\u0026#39;,.\u0026#39;, \u0026#39;，。\u0026#39;) \u0026gt;\u0026gt;\u0026gt; s.translate(table) \u0026#39;明明是中文，却使用了英文标点。\u0026#39; .rsplit()，就是 split() 的镜像“逆序”方法。 #从右往左切割，None表示以所有的空白字符串切割 \u0026gt;\u0026gt;\u0026gt; log_line.rsplit(None, maxsplit=1) [\u0026#39;\u0026#34;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\u0026#34;\u0026#39;, \u0026#39;47632\u0026#39;] 2. 字符串格式化 # 推荐使用 f-string 字符串格式化。\nusername, score = \u0026#39;piglei\u0026#39;, 100 # f-string，最短最直观 print(f\u0026#39;Welcome {username}, your score is {score:d}\u0026#39;) # 输出： # Welcome piglei, your score is 100 3. Jinja2 模板处理字符串 # Jinja2 是一个用于 Python 的模板引擎，可以用来生成动态内容。它通过在模板中嵌入变量和控制结构（如循环和条件）来处理字符串。\nfrom jinja2 import Template _MOVIES_TMPL = \u0026#39;\u0026#39;\u0026#39;\\ Welcome, {{username}}. {%for name, rating in movies %} * {{ name }}, Rating: {{ rating|default(\u0026#34;[NOT RATED]\u0026#34;, True) }} {%- endfor %} 这个字符串 _MOVIES_TMPL 是一个 Jinja2 模板，包含以下内容：\n{{username}} 是一个占位符，将被传入的 username 变量替换。 {%for name, rating in movies %}\u0026hellip;{% endfor %} 是一个循环结构，用于遍历传入的 movies 列表。 {{ name }} 是每部电影的名字，占位符将被电影的名字替换。 {{ rating|default(\u0026quot;[NOT RATED]\u0026quot;, True) }} 是电影的评分，占位符将被电影的评分替换。如果评分不存在，则使用默认值 [NOT RATED]。 3. timeit 模块测试性能 # Python有一个内置模块timeit，利用它，我们可以非常方便地测试代码的执行效率。\n首先，定义需要测试的两个函数：\n#定义一个长度为 100的词汇列表 WORDS = [\u0026#39;Hello\u0026#39;, \u0026#39;string\u0026#39;, \u0026#39;performance\u0026#39;, \u0026#39;test\u0026#39;] * 25 def str_cat(): \u0026#34;\u0026#34;\u0026#34;使用字符串拼接\u0026#34;\u0026#34;\u0026#34; s = \u0026#39;\u0026#39; for word in WORDS: s += word return s def str_join(): \u0026#34;\u0026#34;\u0026#34;使用列表配合 join 产生字符串\u0026#34;\u0026#34;\u0026#34; l = [] for word in WORDS: l.append(word) return \u0026#39;\u0026#39;.join(l) 然后，导入timeit模块，定义性能测试：\nimport timeit # 默认执行 100 万次 cat_spent = timeit.timeit(setup=\u0026#39;from __main__import str_cat\u0026#39;, stmt=\u0026#39;str_cat()\u0026#39;) print(\u0026#34;cat_spent:\u0026#34;, cat_spent) join_spent = timeit.timeit(setup=\u0026#39;from __main__import str_join\u0026#39;, stmt=\u0026#39;str_join()\u0026#39;) print(\u0026#34;join_spent\u0026#34;, join_spent) # 输出 # cat_spent: 7.844882188 # join_spent 7.310863505 第 3 章 容器类型 # 讲解了四种容器类型，列表，元组，字典，集合。同时介绍了对象的可变性、可哈希性等概念。\n1. 列表 # 这里主要记录列表的性能陷阱\n1. 插入数据 # 如果要在头部插入数据，使用 .insert() 平均时间复杂度是 O(n)（尾部插入数据使用 .append() 平均复杂度是 O(1)）。\n如果需要往列表头部插入数据，使用 collections.deque 类型来替代列表（代码如下）。因为 deque 底层使用了双端队列，无论在头部还是尾部追加成员，时间复杂度都是 O（1）。\nfrom collections import deque def deque_append(): \u0026#34;\u0026#34;\u0026#34;不断往尾部追加\u0026#34;\u0026#34;\u0026#34; l = deque() for i in range(5000): l.append(i) def deque_appendleft(): \u0026#34;\u0026#34;\u0026#34;不断往头部插入\u0026#34;\u0026#34;\u0026#34; l = deque() for i in range(5000): l.appendleft(i) # timeit 性能测试代码已省略 # deque_append: 3.739269677 # deque_appendleft 3.7188512409999994 2. 判断成员是否存在 # 要判断某个容器是否包含特定成员，用集合比用列表更合适。\n完成这种操作需要的时间复杂度是O（1）。\n如果代码需要进行 in 判断，可以考虑把目标容器转换成集合类型，作为查找时的索引使用：\n#注意：这里的示例列表很短，所以转不转集合对性能的影响可能微乎其微 # 在实际编码时，列表越长、执行的判断次数越多，转成集合的收益就越高 VALID_NAMES = [\u0026#34;piglei\u0026#34;, \u0026#34;raymond\u0026#34;, \u0026#34;bojack\u0026#34;, \u0026#34;caroline\u0026#34;] # 转换为集合类型专门用于成员判断 VALID_NAMES_SET = set(VALID_NAMES) def validate_name(name): if name not in VALID_NAMES_SET: raise ValueError(f\u0026#34;{name} is not a valid name!\u0026#34;) 这样的话一次转换成集合 O（n）之后，后面查找都可以在 O（1）内。\n2. 元组 # 1. 存放结构化数据 # 和列表不同，在同一个元组里可以出现不同类型的值，因此元组经常用来存放结构化数据。\n\u0026gt;\u0026gt;\u0026gt; user_info = (\u0026#39;piglei\u0026#39;, \u0026#39;MALE\u0026#39;, 30, True) \u0026gt;\u0026gt;\u0026gt; user_info[2] 30 2. 具名数组 # 具名元组（namedtuple）。具名元组在保留普通元组功能的基础上，允许为元组的每个成员命名，这样你便能通过名称而不止是数字索引访问成员。（结构化数据）\n用到 namedtuple() 函数创建具名数组：\nfrom collections import namedtuple Rectangle = namedtuple(\u0026#39;Rectangle\u0026#39;, \u0026#39;width, height\u0026#39;) rect = Rectangle(100, 20) rect = Rectangle(width=100, height=20) print(rect[0]) # 100 print(rect.width) # 100 【推荐】在Python 3.6版本以后，除了使用 namedtuple() 函数以外，你还可以用 typing.NamedTuple 和类型注解语法来定义具名元组类型。\n另外对于这种未来可能会变动的多返回值函数来说，如果一开始就使用 NamedTuple 类型对返回结果进行建模，后面改动会变得简单许多:\nclass Rectangle(NamedTuple): width: int height: int rect = Rectangle(100, 20) 3. 字典 # 1. 访问不存在的 Key # 当用不存在的键访问字典内容时，程序会抛出 KeyError 异常。\ntry: rating = movie[\u0026#39;rating\u0026#39;] except KeyError: rating = 0 2. 快速合并字典 # 在不改变原字典内容的前提下，采用双星号 ** 运算符来做解包操作。在字典中使用 **dict_obj 表达式，可以动态解包 dict_obj 字典的所有内容，并与当前字典合并：\n解包过程会默认进行 浅拷贝操作。\n\u0026gt;\u0026gt;\u0026gt; d1 = {\u0026#39;name\u0026#39;: \u0026#39;apple\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d2 = {\u0026#39;price\u0026#39;: 10} # d1、d2 原始值不会受影响 \u0026gt;\u0026gt;\u0026gt; {**d1, **d2} {\u0026#39;name\u0026#39;: \u0026#39;apple\u0026#39;, \u0026#39;price\u0026#39;: 10} 4. 集合 # 集合只能存放 可哈希的对象。\n5. 对象的可变性 # Python里的内置数据类型，大致上可分为可变与不可变两种。\n可变（mutable）：列表、字典、集合。 不可变（immutable）：整数、浮点数、字符串、字节串、元组。 一个最常见的场景“函数调用”:\n在对字符串进行 += 操作时，因为字符串是不可变类型，所以程序会生成一个新对象（值）：\u0026lsquo;foo suffix\u0026rsquo;，并让 in_func_obj 变量指向这个新对象；旧值（原始变量orig_obj指向的对象）则不受任何影响。\n对字符串对象执行+=操作 如果对象是可变的（比如列表），+= 操作就会直接原地修改 in_func_obj 变量所指向的值，而它同时也是原始变量 orig_obj 所指向的内容；待修改完成后，两个变量所指向的值（同一个）肯定就都受到了影响。\n对列表对象执行+=操作 6. 深拷贝与浅拷贝 # 假如我们想让两个变量（可变的）的修改操作互不影响，就需要拷贝变量所指向的可变对象，做到让不同变量指向不同对象。\n按拷贝的深度，常用的拷贝操作可分为两种：浅拷贝与深拷贝。\n1. 浅拷贝 # 使用copy模块下的 copy() 方法 \u0026gt;\u0026gt;\u0026gt; import copy \u0026gt;\u0026gt;\u0026gt; nums_copy = copy.copy(nums) \u0026gt;\u0026gt;\u0026gt; nums[2] = 30 # 修改不再相互影响 \u0026gt;\u0026gt;\u0026gt; nums, nums_copy ([1, 2, 30, 4], [1, 2, 3, 4]) 使用各容器类型的内置构造函数 \u0026gt;\u0026gt;\u0026gt; d2 = dict(d.items()) \u0026gt;\u0026gt;\u0026gt; nums_copy = list(nums) 进行全切片 #nums_copy会变成 nums的浅拷贝 \u0026gt;\u0026gt;\u0026gt; nums_copy = nums[:] 有些类型自身就提供了浅拷贝方法 #列表有 copy方法 \u0026gt;\u0026gt;\u0026gt; num = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; nums.copy() [1, 2, 3, 4] # 字典也有 copy 方法 \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;foo\u0026#39;: \u0026#39;bar\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d.copy() {\u0026#39;foo\u0026#39;: \u0026#39;bar\u0026#39;} 2. 深拷贝 # 但对于一些层层嵌套的复杂数据来说，浅拷贝仍然无法解决嵌套对象被修改的问题。\n可以用 copy.deepcopy() 函数来进行深拷贝操作\n\u0026gt;\u0026gt;\u0026gt; items = [1, [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], 2, 3] \u0026gt;\u0026gt;\u0026gt; items_deep = copy.deepcopy(items) 7. 对象的可哈希性 # 计算哈希值的过程，是通过调用内置函数hash(obj)完成的。如果对象是可哈希的，hash函数会返回一个整型结果，否则将会报 TypeError 错误。\n某种类型是否可哈希遵循下面的规则：\n所有的不可变内置类型，都是可哈希的，比如str、int、tuple、frozenset等； 所有的可变内置类型，都是不可哈希的，比如dict、list，set等； 对于不可变容器类型(tuple, frozenset)，仅当它的所有成员都不可变时，它自身才是可哈希的； 用户定义的类型默认都是可哈希的。谨记，只有可哈希的对象，才能放进集合或作为字典的键使用。 只有可哈希的对象，才能放进集合或作为字典的键使用。 8. 生成器 # 生成器（generator）是Python里的一种特殊的数据类型。顾名思义，它是一个不断给调用方“生成”内容的类型。定义一个生成器，需要用到生成器函数与 yield 关键字。\ndef generate_even(max_number): \u0026#34;\u0026#34;\u0026#34;一个简单生成器，返回 0 到 max_number 之间的所有偶数\u0026#34;\u0026#34;\u0026#34; for i in range(0, max_number): if i % 2 == 0: yield i for i in generate_even(10): print(i) yield 和 return 的最大不同之处在于，return 的返回是一次性的，使用它会直接中断整个函数执行，而 yield 可以逐步给调用方生成结果：\n(其实可以把生成器返回的值想象成一个可以迭代的 list，需要迭代得出。)\n\u0026gt;\u0026gt;\u0026gt; i = generate_even(10) \u0026gt;\u0026gt;\u0026gt; next(i) 0 \u0026gt;\u0026gt;\u0026gt; next(i) 2 调用 next()可以逐步从生成器对象里拿到结果。\n因为生成器是可迭代对象，所以你可以使用list()等函数方便地把它转换为各种其他容器类型：\n\u0026gt;\u0026gt;\u0026gt; list(generate_even(10)) [0, 2, 4, 6, 8] 第 4 章 条件分支控制流 # 1. 分支惯用写法 # 1. 不要显式地和布尔值做比较 # #不推荐的写法 # if user.is_active_member() == True: # 推荐写法 if user.is_active_member(): 2. 省略零值判断 # 当我们需要在条件语句里做空值判断时，可以直接把代码简写成下面这样：\nif not containers_count: ... if fruits_list: ... · 布尔值为假：None、0、False、[]、()、{}、set()、frozenset()，等等。\n· 布尔值为真：非0的数值、True，非空的序列、元组、字典，用户定义的类和实例，等等。\n3. 与None比较时使用is运算符* # 当你需要判断某个对象是否是 None、True、False时，使用 is ，其他情况下，请使用 ==。\n2. 常用函数优化分支 # 1. 使用bisect优化范围类分支判断 # 当在每个 if/elif 语句后，都跟着一个分界点时，\nbisect 是 Python 内置的二分算法模块，它有一个同名函数 bisect，可以用来在有序列表里做二分查找。\n\u0026gt;\u0026gt;\u0026gt; import bisect # 注意：用来做二分查找的容器必须是已经排好序的 \u0026gt;\u0026gt;\u0026gt; breakpoints = [10, 20, 30] # bisect 函数会返回值在列表中的位置，0 代表相应的值位于第一个元素 10 之前 \u0026gt;\u0026gt;\u0026gt; bisect.bisect(breakpoints, 1) 0 # 3 代表相应的值位于第三个元素 30 之后 \u0026gt;\u0026gt;\u0026gt; bisect.bisect(breakpoints, 35) 3 2. all()/any() 函数 # all() 和 any()。这两个函数接收一个可迭代对象作为参数，返回一个布尔值结果。顾名思义，这两个函数的行为如下。\nall(iterable)：仅当iterable中所有成员的布尔值都为真时返回 True，否则返回 False。 any(iterable)：只要iterable中任何一个成员的布尔值为真就返回 True，否则返回 False。 def all_numbers_gt_10_2(numbers): return bool(numbers) and all(n \u0026gt; 10 for n in numbers) 3. 其他技巧 # 1. 要竭尽所能地避免分支嵌套 # 用一个简单的技巧来优化——“提前返回”。\n“提前返回”指的是：当你在编写分支时，首先找到那些会中断执行的条件，把它们移到函数的最前面，然后在分支里直接使用 return 或 raise 结束执行。\n2. 德摩根定律 # 德摩根定律”告诉了我们这么一件事：\nnot A or not B等价于not (A and B)。\n#如果用户没有登录或者用户没有使用Chrome，拒绝提供服务 if not user.has_logged_in or not user.is_from_chrome: return \u0026#34;our service is only available for chrome logged in user\u0026#34; # 等价于下面 if not (user.has_logged_in and user.is_from_chrome): return \u0026#34;our service is only available for chrome logged in user\u0026#34; 3. and和or的运算优先级 # and 运算符的优先级高于 or ！\n4. or运算符的陷阱 # 使用 a or b 来表示 “ a为空时用b代替” 的写法非常常见。\n但是，因为or计算的是变量的布尔真假值，所以不光是None，0、[]、{}以及其他所有布尔值为假的东西，都会在or运算中被忽略：\n#所有的0、空列表、空字符串等，都是布尔假值 \u0026gt;\u0026gt;\u0026gt; bool(None), bool(0), bool([]), bool({}), bool(\u0026#39;\u0026#39;), bool(set()) (False, False, False, False, False, False) 所以在使用 a or b 时候，一定要注意变量的布尔值真假。\n第 5 章 异常与错误处理 # 本章主要是作者对异常处理的经验和技巧。\n1. 异常捕获的经验技巧 # 1. 优先使用异常捕获 # Python社区明显偏爱基于异常捕获的EAFP（asier to ask for forgiveness than permission）风格。\nEAFP编程风格更为简单直接，它总是直奔主流程而去，把意外情况都放在异常处理try/except块内消化掉。\n所以，每当直觉驱使你写下if/else来进行错误分支判断时，请先把这份冲动放一边，考虑用try来捕获异常是不是更合适。\n2. try/except结构 # 常见的 try/except 基础语法如下：\ndef safe_int(value): \u0026#34;\u0026#34;\u0026#34;尝试把输入转换为整数\u0026#34;\u0026#34;\u0026#34; try: return int(value) except TypeError: # 当某类异常被抛出时，将会执行对应 except 下的语句 print(f\u0026#39;type error: {type(value)} is invalid\u0026#39;) except ValueError: # 你可以在一个 try 语句块下写多个 except print(f\u0026#39;value error: {value} is invalid\u0026#39;) finally: # finally 里的语句，无论如何都会被执行，哪怕已经执行了return print(\u0026#39;function completed\u0026#39;) 3. 把更精确的 except 语句放在前面 # 如果一个try代码块里包含多条 except，异常匹配会按照从上而下的顺序进行。\n这时，假如你不小心把一个比较模糊的父类异常放在前面，就会导致在下面的 except 永远不会被触发。\n所以，把更精确的异常放在前面。\nPython 的内置异常类之间存在许多继承关系，具体可以看 Python3.info。\nException Hierarchy 4. else 分支 # 如果使用 try 语句块里的 else 分支，代码可以变得更简单：\ntry: sync_profile(user.profile, to_external=True) except Exception as e: print(\u0026#34;Error while syncing user profile\u0026#34;) else: send_notification(user, \u0026#39;profile sync succeeded\u0026#39;) 异常捕获语句里的 else 表示：仅当 try 语句块里没抛出任何异常时，才执行 else 分支下的内容，效果就像在 try 最后增加一个标记变量一样。\n和finally语句不同，假如程序在执行try代码块时碰到了return或break等跳转语句，中断了本次异常捕获，那么即便代码没抛出任何异常，else分支内的逻辑也不会被执行。\n5. raise 语句 # 在 Python 中，raise 语句用于引发一个异常，即中断程序的正常流程并生成一个错误。\nraise Exception(\u0026#34;这是一个一般性的错误\u0026#34;) # 输出 # Traceback (most recent call last): # File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; # Exception: 这是一个一般性的错误 当我们想仅仅想记录下某个异常，然后把它重新抛出时，可以使用不带任何参数的 raise 语句。\ndef incr_by_key(d, key): try: d[key] += 1 except KeyError: print(f\u0026#39;key {key} does not exists, re-raise the exception\u0026#39;) raise 当一个空 raise 语句出现在 except 块里时，它会原封不动地重新抛出当前异常及异常类型。\n6. 可以自定义异常类 # class CreateItemError(Exception): \u0026#34;\u0026#34;\u0026#34;创建 Item 失败\u0026#34;\u0026#34;\u0026#34; def create_item(name): \u0026#34;\u0026#34;\u0026#34;创建一个新的Item :raises: 当无法创建时抛出 CreateItemError \u0026#34;\u0026#34;\u0026#34; if len(name) \u0026gt; MAX_LENGTH_OF_NAME: raise CreateItemError(\u0026#39;name of item is too long\u0026#39;) if len(get_current_items()) \u0026gt; MAX_ITEMS_QUOTA: raise CreateItemError(\u0026#39;items is full\u0026#39;) return Item(name=name), \u0026#39;\u0026#39; def create_from_input(): name = input() try: item = create_item(name) except CreateItemError as e: print(f\u0026#39;create item failed: {e}\u0026#39;) else: print(f\u0026#39;item\u0026lt;{name}\u0026gt; created\u0026#39;) 7. 不要手动做数据校验 # 在编写代码时，我们应当尽量避免手动校验任何数据。 因为数据校验任务独立性很强，所以应该引入合适的第三方校验模块（或者自己实现），让它们来处理这部分专业工作。\n假如你在开发Web应用，数据校验工作通常来说比较容易。比如Django框架就有自己的表单验证模块，Flask也可以使用WTForms模块来进行数据校验。\n第 6 章 循环与可迭代对象 # 本章主要是分享在 Python 里编写循环的一些经验和技巧，重点时迭代器与迭代器的使用。\n1. iter() 与 next() 内置函数 # iter() 会尝试返回一个迭代器对象\n\u0026gt;\u0026gt;\u0026gt; iter([1, 2, 3]) \u0026lt;list_iterator object at 0x101a82d90\u0026gt; \u0026gt;\u0026gt;\u0026gt; iter(\u0026#39;foo\u0026#39;) \u0026lt;str_iterator object at 0x101a99ed0\u0026gt; \u0026gt;\u0026gt;\u0026gt; iter（1） Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;int\u0026#39; object is not iterable # 对不可迭代的类型执行iter()会抛出TypeError异常 什么是迭代器（iterator）？\n顾名思义，这是一种帮助你迭代其他对象的对象。迭代器最鲜明的特征是：不断对它执行 next() 函数会返回下一次迭代结果。\n\u0026gt;\u0026gt;\u0026gt; l = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] # 首先通过 iter 函数拿到列表 l 的迭代器对象 \u0026gt;\u0026gt;\u0026gt; iter_l = iter(l) \u0026gt;\u0026gt;\u0026gt; iter_l \u0026lt;list_iterator object at 0x101a8c6d0\u0026gt; # 然后对迭代器调用next() 不断获取列表的下一个值 \u0026gt;\u0026gt;\u0026gt; next(iter_l) \u0026#39;foo\u0026#39; \u0026gt;\u0026gt;\u0026gt; next(iter_l) \u0026#39;bar\u0026#39; 当迭代器没有更多值可以返回时，便会抛出 StopIteration 异常。\n2. 自定义迭代器 # 要自定义一个迭代器类型，关键在于实现下面这两个魔法方法：\n· __iter__ ：调用iter()时触发，迭代器对象总是返回自身。\n· __next__ ：调用next()时触发，通过 return 来返回结果，没有更多内容就抛出 StopIteration 异常，会在迭代过程中多次触发。\n3. 生成器是迭代器 # 生成器还是一种简化的迭代器实现, 使用它可以大大降低实现传统迭代器的编码成本。 基本不需要通过 __iter__ 和 __next__ 来实现迭代器，只要写上几个 yield 就行。\ndef range_7_gen(start, end): \u0026#34;\u0026#34;\u0026#34;生成器版本的Range7Iterator\u0026#34;\u0026#34;\u0026#34; num = start while num \u0026lt; end: if num != 0 and (num % 7 == 0 or \u0026#39;7\u0026#39; in str(num)): yield num num += 1 我们可以用 iter() 和 next() 函数来验证“生成器就是迭代器”这个事实：\n\u0026gt;\u0026gt;\u0026gt; nums = range_7_gen(0, 20) # 使用iter() 函数测试 \u0026gt;\u0026gt;\u0026gt; iter(nums) \u0026lt;generator object range_7_gen at 0x10404b2e0\u0026gt; \u0026gt;\u0026gt;\u0026gt; iter(nums) is nums True # 使用next() 不断获取下一个值 \u0026gt;\u0026gt;\u0026gt; next(nums) 7 \u0026gt;\u0026gt;\u0026gt; next(nums) 14 生成器（generator） 利用其简单的语法，大大降低了迭代器的使用门槛，是优化循环代码时最得力的帮手。\n4. 修饰可迭代对象优化循环 # 这里主要讲的是一种循环代码的优化思路，通过修饰可迭代对象来优化循环。\n通俗的来讲其实就是：迭代（迭代器）。可以类比与 enumerate 的做法。\n“修饰可迭代对象”是指用生成器（或普通的迭代器）在循环外部包装原本的循环主体，完成一些原本必须在循环内部执行的工作——比如过滤特定成员、提供额外结果等，以此简化循环代码。\n5. 读取大文件 # 调用 file.read(chunk_size) ,会马上读取从当前游标位置往后 chunk_size 大小的文件内容. 解决读取大文件的性能问题。\nfrom functools import partial def count_digits_v3(fname): count = 0 block_size = 1024 * 8 with open(fname) as fp: # 使用functools.partial 构造一个新的无须参数的函数 _read = partial(fp.read, block_size) # 利用iter() 构造一个不断调用_read 的迭代器 for chunk in iter(_read, \u0026#39;\u0026#39;): for s in chunk: if s.isdigit(): count += 1 return count ","date":"2024-07-06","externalUrl":null,"permalink":"/booknote/python%E5%B7%A5%E5%8C%A0%E4%B8%8A/","section":"读书","summary":"","title":"《Pyhotn工匠——案例、技巧与工程实践》(上)","type":"booknote"},{"content":"","date":"2024-06-29","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"Github","type":"tags"},{"content":" 引言 # 当 Github 上的关联邮箱修改之后，会发现原来的 commit 在 GitHub 的 Contribution 里面不见了 😅 ，同时本地提交的 commit，也不会在 Contribution 里面显示。\n根本原因就是本地的邮箱和用户名和 Github 上的邮箱不一致，本地的邮箱和用户名还是之前的邮箱用户名。\n那么下面就来解决这个问题。\n修改本地邮箱和用户名 # 查看全局配置的用户名和邮箱\n全局配置是对所有仓库生效的设置。可以使用以下命令查看全局配置的用户名和邮箱：\ngit config --global user.name git config --global user.email 下面我们要把 commit 时的用户名和邮箱地址改为与 Github 上设置的一致，我们可以通过下面的命令：\ngit config --global user.name \u0026lt;your username for Github\u0026gt; git config --global user.email \u0026lt;your email address for Github\u0026gt; 修改后，再提交 commit ，就会看到 commit 被记入 Contribution 了。\n找回之前提交的 Contriubtion # 现在我们需要找回之前提交的 commit。\n1. 查看当前本地仓库中的提交： # git shortlog 命令可以对所有提交的作者进行汇总：\ngit shortlog -s -e s：显示每个作者的提交数量 e：显示作者的电子邮件地址 此时本地仓库应该显示之前邮箱的 commit 数量，并没有新邮箱的 commit，这就是 Github 上不显示 contribute 的原因。\n所以我们需要逐个仓库进行修改之前提交的 commit (的邮箱和用户名)。\n你想恢复几个仓库的 contribute，就重复几次下面的步骤。\n2. 将要修改的repo克隆到本地 # git clone --bare \u0026lt;the repo address\u0026gt; git \u0026ndash;bare 命令，用于克隆一个裸仓库（bare repository）。裸仓库是一种特殊的 Git 仓库，它只包含 Git 的版本控制数据，而不包含工作目录中的文件。\n3. 将命令行的当前目录切换到新克隆的库下 # cd \u0026lt;the repo path\u0026gt; 4. 编写脚本 # 根据你的信息修改以下变量，运行脚本。\n#!/bin/sh git filter-branch --env-filter \u0026#39; OLD_EMAIL=\u0026#34;需要被替换的邮箱\u0026#34; NEW_NAME=\u0026#34;新的用户名\u0026#34; NEW_EMAIL=\u0026#34;新的邮箱\u0026#34; if [ \u0026#34;$GIT_COMMITTER_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_COMMITTER_NAME=\u0026#34;$NEW_NAME\u0026#34; export GIT_COMMITTER_EMAIL=\u0026#34;$NEW_EMAIL\u0026#34; fi if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_AUTHOR_NAME=\u0026#34;$NEW_NAME\u0026#34; export GIT_AUTHOR_EMAIL=\u0026#34;$NEW_EMAIL\u0026#34; fi \u0026#39; --tag-name-filter cat -- --branches --tags 5. 再次查看查本地仓库（bare repo）中的提交： # 重复 第1步\ngit shortlog -s -e 此时应该能看到，之前的邮箱和用户名，已经被改为了新的邮箱和用户名。\n6. 把正确历史push到Github上 # 把修改好的本地历史信息 push 到 Github 上，之后就可以在网站上看到丢失的 Contribution 信息 😉。\ngit push --force --tags origin \u0026#39;refs/heads/*\u0026#39; git push：将本地的提交推送到远程仓库。\nforce 或 -f：强制推送。使用此选项会覆盖远程仓库中的历史记录，无论远程仓库的状态如何。这通常用于重写远程分支的历史，比如在你使用 git rebase 或 git filter-branch 之后。需要小心使用，以免覆盖他人的工作。\ntags：推送本地所有的标签到远程仓库。标签是对特定提交的引用，通常用于标记版本。\norigin：远程仓库的名称。默认情况下，origin 是克隆仓库时 Git 自动赋予远程仓库的名称。\n\u0026lsquo;refs/heads/\u0026rsquo;：表示本地的所有分支。refs/heads/ 是 Git 中保存分支的引用路径， 是通配符，表示所有分支。\n额外问题 # 此时已经解决了修改邮箱之后，历史 commit 丢失的问题。\n但是当在我之前本地的仓库中（非刚才 clone 的 bare 仓库），输入 git log，发现还是之前的 commit 信息 🙃。\n其实就是因为没有更新到远程仓库的信息。\n此时可以选择\ngit pull origin master --allow-unrelated-histories 会有冲突，解决冲突。\n或者选择更简单的方法 【比较推荐】：\n重置本地仓库\n强制拉取远程仓库的最新历史\n确定本地的更改已经保存！ git fetch origin git reset --hard origin/main 此时本地仓库的历史提交信息也更新了 🥰\n参考资料 # GitHub 修改 Commit 用户名和邮箱\n解决Github的Contribution没有增加的问题\n","date":"2024-06-29","externalUrl":null,"permalink":"/blog/github-%E9%82%AE%E7%AE%B1%E6%9B%B4%E6%94%B9%E4%B9%8B%E5%90%8E/","section":"归档","summary":"","title":"Github 邮箱更改之后","type":"blog"},{"content":"","date":"2024-06-29","externalUrl":null,"permalink":"/blog/","section":"归档","summary":"","title":"归档","type":"blog"},{"content":"","date":"2024-06-29","externalUrl":null,"permalink":"/tags/%E6%8A%80%E6%9C%AF/","section":"Tags","summary":"","title":"技术","type":"tags"},{"content":" 如果直接想看操作，请看 pr-九步 引言 # Working on [freenode] helped me earn many of the skills I later used for my studies in university and my actual job. I think working on open source projects helps me as much as it helps the project!\n— @errietta, \u0026ldquo;Why I love contributing to open source software\u0026rdquo;\n首先尝试开源之前，强烈推荐阅读 Open Source Guides (附有多种语言)，下文很多做法也是借鉴于这个手册。\n另外非常推荐尝试下面这个 first-contributions 这个项目进行提交，下文也会以这个项目为例，进行一次 contribution 的提交。\nfirstcontributions/first-contributions 🚀✨ Help beginners to contribute to open source projects null 44460 77667 那么就让我们开始吧！🚀\nContribute 前的准备工作 # 在某一个开源项目扎根多年，这意味着你只是对这一个开源项目无比的熟悉。若是切换到不同的项目，可能会发现完全是另外一回事，所谓的使用词汇、习惯用语、沟通方式都发生了变化。\n所以先不要着急提交，先了解一个项目。\n在准备贡献之前，如果你有一个好的想法，做一些快速的检查项（issue、pr），以确保没有人讨论过你的想法。\n如果没有人提这个 issue，先创建一个 issue： 报告你自己无法解决的错误 讨论一个高级主题或想法(例如. 社区、远景、政策等) 期望实现某新的特性，或者其它项目的想法 如果刚好有一个开放的 issue，和你不谋而合： 添加评论，告诉他人你将负责这个。这样的话，可以避免他人重复劳动。 如果说某个 issue 已经开放很久了， 这可能是已经有人正在解决中，又或者是早已经解决过了，所以也请添加评论，在打算开启工作之前，最好是确认一下。 如果你创建了一个 issue，但是没多久自己解决了， 也要添加评论，让其他人知道，然后关闭该 issue。记录本身就是为社区的贡献。 Contribute 步骤 # 下面会以 first-contributions 这个项目为例，进行提交。\n1. Fork（复制）远程代码仓库 # 点击图示中的按钮去 Fork 这个代码仓库。 这个操作会将代码仓库复制到你的账户名下。\n2. Clone（克隆）代码仓库到本地 # 使用 git clone 命令将 fork 的代码仓库克隆到本地，\n进入到本地仓库的目录。\ngit clone \u0026#34;your fork repo\u0026#34; cd \u0026#34;your fork repo\u0026#34; 3. 💥💥【关于同步】（理论内容，但是很重要！）💥💥 # 冲突一定要在本地搞定之后再推送！ 首先，我们有 3 个不同的存储库：在 Github 上的公共存储库 github.com/firstcontributions/first-contributions.git、在 GitHub 上对该存储库的 fork github.com/Your-Name/first-contributions/ 以及 本地计算机存储库。这种合作对于开源项目来说是典型的，称为 Triangle Workflows。\n为了使你的两个 repo 与远端的公共存储库保持同步，首先必须获取公共存储库并将其与您本地计算机的存储库合并。我们的第二步是将您的本地存储库推送到您的 GitHub fork。之后，从你的 fork 请求 “pull request”。\n在操作中注意以下几个原则：\n对别人的项目贡献PR，要用自己的 feature-branch。 每次准备 coding 之前保证自己的本地的 main-branch 是已经同步上游仓库的（目的是使新建的 feature-branch 是最新的）。 自己的 fork repo 的 main-branch 不一定要是最新的，一般都是落后上游并从不更新（因为每次更新和 push 都是用 feature-branch）。 每次修改完 feature-branch，要再次同步上游仓库，保证之后的 pr 没有冲突（降低冲突概率，也可能会有）。 所以可以看出为了避免 conflict（将 conflict 处理于本地），整个提交 pr 的过程中会涉及两次同步。\n第一次是准备 coding 之前（新建 featur-branch 之前），保证 main/feature branch 同步（这次可以采用git reset --hard origin/master，强制同步，下文会讲）。 第二次是准备 push 之前, 保证 feature-branch 同步（这次采用 git merge, 处理conflict）。 所以一直在保持同步上游仓库的分支，理论上只有 featur-branch，而 main-branch 只有在下次要提交新的 pr 之前再同步（当然，你也可以在对方接受了 pr 之后，找个时间同步一下 main-branch，什么时候都好。）\n如果想了解同步的更多方式，可以查阅 ：\nGithub进行fork后如何与原仓库同步：重新fork很省事，但不如反复练习版本合并 #67\n（更多是借鉴于 frostming大佬的做法） 如何参与Tianchi(天池)项目以及如何贡献代码 4. 在本地的仓库配置”上游”为远端仓库 # 执行命令 git remote 查看你的远程仓库的路径:\ngit remote -v 你可以查看当前本地仓库中已经配置的远程仓库地址。通常，你会看到 origin 对应的是你 fork 的仓库。\n如果只有上面2行，说明你未设置 upstream （中文叫：上游代码库）。一般情况下，设置好一次 upstream 后就无需重复设置。\n此时你应该是在你的 main-branch，如果不放心可以使用 git branch, 查看当前命令。\n执行命令 git remote add upstream 把远端的仓库设置为你的 upstream 。这个命令执行后，没有任何返回信息；所以再次执行命令 git remote -v 检查是否成功。\n$ git remote add upstream https://github.com/firstcontributions/first-contributions 执行后显示：\n5. 同步本地的仓库与上游仓库（第一次同步） # 切记，这步一定要在本地的 main-branch 分支执行，如果不确定，就使用 git branch 查看当前分支， 使用 git checkout main 切换到 main-branch。\n获取上游仓库的最新更改： git fetch upstream 该命令从上游仓库（upstream）获取所有分支和最新的提交，但不会自动合并或修改本地分支。\n重置（强制同步）本地 main-branch： git reset --hard upstream/main Q：上游的主分支是 upstream/main 还是 upstream/master？\nA：由于历史原因，2020年，为了消除术语中的潜在歧视性含义，Git 项目和许多开源社区决定将默认主分支名称从 master 改为 main。\n所以在使用 git reset --hard 之前可以先使用 git branch -r 查看上游所有分支，查看 upstream 的默认主分支是 main 还是 master。\n在执行 git reset \u0026ndash;hard upstream/main 命令之前，请确保已经将所有重要的更改提交到其他分支或保存到其他地方，因为此命令会丢弃本地 main 分支上的所有未提交的更改。 5. 新建分支 # 新建一个新的分支，在新的分支上进行开发，确保 main 分支保持同步且不受干扰。这使得 main 分支可以随时用于同步最新的上游代码。\n新建分支并且切换到新分支：\ngit branch add-myname git checkout add-myname 或者直接使用：\ngit checkout -b add-myname 新建分支名字时，确保清晰、易于理解，区分 issue 和 feature。例如：\nfeature/add-user-authentication\nfix/issue-1234-bug-fix\nupdate/readme-improvements\nhotfix/production-bug-fix\n6. 对代码进行修改，然后 Commit (提交) 修改 # 此时代码修改的操作，都是在你新建的branch上进行。 在本文的例子中，\n打开 Contributors.md 这个文件，更新文件内容，将你的名字加上去，保存修改。git status 这命令会列出被改动的文件。接着 git add 这命令则可以添加你的改动。\n现在就可以使用 git commit 命令 commit 你的修改了。\ngit commit -m \u0026#34;Add \u0026lt;你的名字\u0026gt; to Contributors list\u0026#34; 将 \u0026lt;你的名字\u0026gt; 替换成你的名字\n之后就可以使用 git push 命令, 将新分支推送到 fork 仓库：\ngit push origin add-myname 现在你的 fork repo 应该就会有你已经提交的新分支和内容。\n你可以重复此步，来不断修改代码、推动代码到自己的 fork 仓库，根据不同情况，这个过程可能会持续很久，或者一次就好。\n如果你已经完成了修改，准备好进行 pr 了，那么往下看。\n（加油！就快完事了😀）\n7. pr 之前，再次同步本地的分支与上游仓库（第二次同步） # 因为你在修改代码的过程中，可能远程仓库已经有所更改。\n这步就是为了避免 pr 之后再解决 conflict 的问题，而是在提交之前，讲 conflict 解决在本地。\n此时代码修改的操作，仍然在你新建的 branch 上进行。 在 feature 分支上直接从上游仓库获取最新的更新： git fetch upstream 将上游仓库的最新更改合并到 feature 分支： git merge upstream/main 解决冲突（如果有）： 如果在合并过程中遇到冲突，手动解决冲突。\n继续 merge： git merge --continue 8. 再次 Commit (提交) \u0026amp;\u0026amp; Push（推送） # 类似 第6步, 将分支代码 push 到 fork repo。\ngit add . git commit -m \u0026#34;new feature\u0026#34; git push origin add-myname 9. 提出 Pull Request 将你的修改供他人审阅 # 前往你的 Github 代码仓库，你会看到一个 Contribute 的按钮。点击该按钮，之后点击 OPen pull request。\n接着可以填写 Pull Request 表单，描述你的 pr，接着再点击 Create pull request 按钮，正式提交 pull request。\n之后便可以在远程仓库中看到你的 PR。\n而且能在里面看到你之前的 commit。\n当你提交了之后会发生什么 # 在你提交了贡献之后，下面几种情形是可能发生的：\n😭 没有人响应你。 # 即使在一个活跃的项目中，你的贡献也有可能得不到响应。\n如果过去了一周，依旧没有人响应，请心平气和的在后面跟帖，询求他人帮助你审核。如果你熟悉某个人可以审核你的贡献，你可以使用@+名字，直接提醒他一下。\n如果你做了所有该做的事情，还是没有人理你，那就是真的没有人对你的贡献做出响应。这可能令人难受，但是千万不要灰心，每个人都会遇到这样的情况。你没有得到回复的原因有很多，包括你无法控制的个人情况。再接再厉，试着寻找另一个项目或方式来做出贡献。\n🚧 有人要求你对自己的提交做出变更。 # 被要求修改你的提交是很常见的，无论是对你的想法的反馈，还是对你代码的改动。\n当有人提出变更时，请及时响应。他们花时间审核了你的提交，要尊重他们。开启 PR 然后一走了之是一种恶习。如果你不知道如何修改，请花时间深入研究，并在需要时寻求他人帮助。\n如果你没有时间继续处理这个 issue（举例来说，如果对话持续了几个月，而你情况有变），那么请告知维护者你无法再及时响应了。或许有其他人乐意接手你的工作\n👎 你的贡献没有被接受。 # 你的贡献最终可能被接受，也可能不被接受。真心希望你没有为此花费太多力气。如果你不确定为什么它不被接受，请维护者提供反馈和说明是完全合理的。但最终，无论如何，你都要对他们的决定表示尊重。不要去无谓的争论或者显露敌意。如果你坚持自己，你仍可以 fork 项目，按照自己的思路来发展分支。\n🎉 你的贡献被采纳。 # 太棒了！你已经成功地完成了一次开源贡献！\nPR 九步： # # Step 1: Fork（复制）远程代码仓库 # Step 2: Clone（克隆）代码仓库到本地 git clone https://github.com/your-name/fork-repo.git cd fork-repo # Step 3: 查看远程仓库路径确认添加成功 git remote -v # Step 4: 添加上游仓库作为 upstream git remote add upstream https://github.com/upstream-owner/original-repo.git git remote -v # Step 5: 同步本地主分支与上游主分支 git fetch upstream git reset --hard upstream/main # 或者 upstream/master # Step 6: 新建一个特性分支进行开发 git checkout -b feature-branch # 在 feature-branch 上做一些更改和提交 # Step 7: 再次同步本地分支与上游仓库的主分支 git checkout feature-branch git fetch upstream git merge upstream/main # 或者 upstream/master # Step 8: 将特性分支推送到你的 Fork 仓库 git add . git commit -m \u0026#34;new feature\u0026#34; git push origin feature-branch # Step 9: 在 GitHub 上创建 Pull Request # - 导航到你的 Fork 仓库页面，选择 feature-branch 分支 # - 点击 \u0026#34;Pull Request\u0026#34; 按钮，创建 PR 到 upstream 的主分支 # - 填写 PR 标题、描述，提交 PR # 请确保在每个步骤执行前理解并确认操作的正确性，特别是在涉及重置和合并的步骤中。 参考资料 # first-contributions\nhow-to-contribute-to-open-source\nOpen Source Guides\nHow To Get Started In Open Source\nGithub进行fork后如何与原仓库同步：重新fork很省事，但不如反复练习版本合并 #67\n如何参与Tianchi(天池)项目以及如何贡献代码\n","date":"2024-06-25","externalUrl":null,"permalink":"/blog/%E5%85%B3%E4%BA%8E-contribution-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","section":"归档","summary":"","title":"关于 Contribution 的那些事","type":"blog"},{"content":"","date":"2024-06-25","externalUrl":null,"permalink":"/tags/%E5%BC%80%E6%BA%90/","section":"Tags","summary":"","title":"开源","type":"tags"},{"content":"","date":"2024-06-23","externalUrl":null,"permalink":"/tags/%E9%93%BE%E6%8E%A5/","section":"Tags","summary":"","title":"链接🔗","type":"tags"},{"content":" 这里面放一些有趣的技术文章链接\n🐍 Python # Python全栈开发从入门到入土\n","date":"2024-06-23","externalUrl":null,"permalink":"/blog/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0%E6%8A%80%E6%9C%AF%E7%AF%87/","section":"归档","summary":"","title":"一些有趣的文章（技术篇）","type":"blog"},{"content":"","date":"2024-06-23","externalUrl":null,"permalink":"/tags/%E8%BD%AC%E5%8F%91/","section":"Tags","summary":"","title":"转发","type":"tags"},{"content":"","date":"2024-06-15","externalUrl":null,"permalink":"/tags/github-action/","section":"Tags","summary":"","title":"Github Action","type":"tags"},{"content":" 1、什么是 Github Action ? # GitHub Actions 是 GitHub 提供的一项 持续集成和持续交付（CI/CD）服务，允许开发者在代码库上自动化各种任务。\n简单来说，你可以把 GitHub Actions 想象成在你的 GitHub 代码仓库里的一个机器人，并且可以根据你给它设定的规则，自动完成一系列任务（Workflow），主要目的就是服务于这个项目（代码仓库）。\n2、基本概念 # Workflow（工作流程）：定义了一系列要自动执行的过程。详情可以见 第三节。\nEvent（事件）：触发 Workflow 工作流的动作，例如 push、pull request、release 等。详情可见 官方文档。\nJob（任务）：一个 Workflow 由一个或多个 Jobs 构成，一次 Workflow 的运行，可以完成多个 Jobs。\nStep（步骤）：每个 Jobs 由多个 Step 构成，一步步完成。\nAction（动作）：每个 Step 可以依次执行一个或多个命令（Action）。\nevent(触发) -\u0026gt; workflow -\u0026gt; job -\u0026gt; step -\u0026gt; action\n3、例子：Github Page 静态博客自动发布 # 使用 Github Action 构建博客自动发布流程。\n之前手动发布静态的博客文件， 需要切换到 public/ 目录进行 push， 更新 Github page 界面\n是否可以在 push到 博客原文件仓库的时候，自动更新 Github Page（Blog）界面呢？\n1. 配置 workflow 文件 # GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的 .github/workflows 目录。\nworkflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为 .yml，比如 blog.yml。\n一个库可以有多个 workflow 文件。GitHub 只要发现 .github/workflows 目录里面有 .yml文件，就会自动运行该文件。\n自动发布示例配置如下：\nname: Automatic Blog Publishing on: push: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: publish: name: auto publish blog runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.AUTO_PUBLISH_BLOG_TOKEN }} EXTERNAL_REPOSITORY: LcenArthas/LcenArthas.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 下面针对上面的 workflow 配置文件，解释其中用到的字段。\nworkflow 文件字段非常多，详见 官方文档\n1. name 字段 # 是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。\nname: Automatic Blog Publishing 2. on 字段 # 指定触发 workflow 的条件，通常是某些事件。下面代码指定，push 事件触发 workflow。\n完整的事件列表，请查看 官方文档。\non.schedule 字段\n除了代码库事件，GitHub Actions 也支持定时运行。注意，时间是使用 POSIX cron 语法将工作流计划为在指定的 UTC 时间运行。\non: push: schedule: # Runs everyday at 8:00 AM (UTC 0:00 AM) - cron: \u0026#34;0 0 * * *\u0026#34; 3. job 字段 # workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。需要给出每一项任务的 job_id，具体名称自定义， 例如我们设置了一个 publish 任务。\njobs.\u0026lt;job_id\u0026gt;.name 字段\n是任务的说明，可以任意写。\njobs.\u0026lt;job_id\u0026gt;.runs-on 字段\n是指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机见 官方文档\njobs: publish: name: auto publish blog runs-on: ubuntu-latest 4. jobs.\u0026lt;job_id\u0026gt;.steps 字段 # 是指作业包含一系列任务，称为 steps。 步骤可以运行命令、运行设置任务，或者运行您的仓库、公共仓库中的操作或 Docker 注册表中发布的操作。\n每个 Job 可以包含一个或多个步骤。\njobs.\u0026lt;job_id\u0026gt;.steps.name字段\n是指步骤名称。\njobs.\u0026lt;job_id\u0026gt;.steps.uses 字段\n是指可以使用在与工作流、 官方actions、 官方actions市场或者 已发布的 Docker 容器映像相同的存储库中定义的操作。\njobs.\u0026lt;job_id\u0026gt;.steps.with 字段\n是指某些操作需要必须使用 with 关键字设置的输入。得看具体引用的工作流需要的参数。\n下面逐步分析每个步骤的作用\nsteps: - name: Checkout uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 上面是引用了 GitHub Action Checkout @v4版本 这个工作流。\n它通常是许多工作流的第一步，用于获取源码（将仓库的内容检出到运行工作流的虚拟机上，使得后续步骤可以访问和操作代码。）\nsubmodules：true，会检出子模块，即我们的主题模块。 fetch-depth: 0，指定检出的提交历史记录深度。默认是 1，即只检出最新的提交。设置为 0 表示完整检出所有历史记录。 例如：\n- name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; 上面是引用了 GitHub Action Hugo setup @v3版本 这个工作流。\n作用是安装指定版本的 Hugo 静态站点生成器。\n例如：\n- name: Build Web run: hugo 这一步骤执行了 hugo 命令，用于运行 Hugo 命令来构建网站。\n例如：\n- name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.AUTO_PUBLISH_BLOG_TOKEN }} EXTERNAL_REPOSITORY: LcenArthas/LcenArthas.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 上面是引用了 GitHub Action GitHub Pages action @v4版本 这个工作流。\n作用是用于将生成的静态网站部署到 GitHub Page。\nEXTERNAL_REPOSITORY: LcenArthas/LcenArthas.github.io，指定要将内容部署到的外部仓库。\nPERSONAL_TOKEN: ${{ secrets.AUTO_PUBLISH_BLOG_TOKEN }}，用于认证的 GitHub 个人访问令牌，通常通过 GitHub Secrets 管理。\ncommit_message: ${{ github.event.head_commit.message }}，使用触发工作流的提交信息作为部署的提交信息。这样可以保留提交历史的上下文信息。\nPUBLISH_BRANCH: main, 指定要推送到的目标分支，如果不想新建分支，指定 Github Page 的主分支（main/master）\n5. 如何创建 secrets.AUTO_PUBLISH_BLOG_TOKEN # 要在 GitHub 账户下 Setting - Developer setting - Personal access tokens 下创建一个 Token。权限需要开启 repo 与 workflow。 配置后复制生成的 Token（注：只会出现一次, 推荐另存一个地方） Make sure to copy your personal access token now. You won’t be able to see it again! 然后在我们博客源仓库的 Settings - Secrets - Actions 中添加 Token， 粘贴在 Secret 中，Name 随便起一个，但是注意要和 PERSONAL_TOKEN: ${{ secrets.AUTO_PUBLISH_BLOG_TOKEN }} 后面的AUTO_PUBLISH_BLOG_TOKEN 一致，这样 GitHub Action 就可以获取到 Token 了。\n完成上述配置后，推送代码至仓库，即可触发 GitHub Action，自动生成博客页面并推送至 GitHub Pages 仓库。 2. 推送本地博客代码至仓库 # 完成上述配置后，推送代码至仓库，即可触发 GitHub Action，自动生成博客页面并推送至 GitHub Pages 仓库。\n可以在仓库的 Actions - All workflows 中看到运行状态和logs。\n参考资料 # [1]. 阮一峰GitHub Actions 入门教程\n[2]. GitHub Actions 官方文档\n[3]. Hugo + GitHub Action，搭建你的博客自动发布系统\n","date":"2024-06-15","externalUrl":null,"permalink":"/blog/github-action-+-%E5%9F%BA%E4%BA%8E-github-page-blog-%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/","section":"归档","summary":"","title":"Github Action + 基于 Github Page Blog 自动发布","type":"blog"},{"content":" About Me # 程序员，阅读者，人间观察者，快乐NPC About Site # 本站生日：2024-06-02 ","date":"2024-06-02","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"About","type":"page"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/movienote/","section":"电影","summary":"","title":"电影","type":"movienote"}]