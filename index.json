
[{"content":" ","date":"2024-06-29","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"2024-06-29","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"Github","type":"tags"},{"content":" 引言 # 当 Github 上的关联邮箱修改之后，会发现原来的 commit 在 GitHub 的 Contribution 里面不见了 😅 ，同时本地提交的 commit，也不会在 Contribution 里面显示。\n根本原因就是本地的邮箱和用户名和 Github 上的邮箱不一致，本地的邮箱和用户名还是之前的邮箱用户名。\n那么下面就来解决这个问题。\n修改本地邮箱和用户名 # 查看全局配置的用户名和邮箱\n全局配置是对所有仓库生效的设置。可以使用以下命令查看全局配置的用户名和邮箱：\ngit config --global user.name git config --global user.email 下面我们要把 commit 时的用户名和邮箱地址改为与 Github 上设置的一致，我们可以通过下面的命令：\ngit config --global user.name \u0026lt;your username for Github\u0026gt; git config --global user.email \u0026lt;your email address for Github\u0026gt; 修改后，再提交 commit ，就会看到 commit 被记入 Contribution 了。\n找回之前提交的 Contriubtion # 现在我们需要找回之前提交的 commit。\n1. 查看当前本地仓库中的提交： # git shortlog 命令可以对所有提交的作者进行汇总：\ngit shortlog -s -e s：显示每个作者的提交数量 e：显示作者的电子邮件地址 此时本地仓库应该显示之前邮箱的 commit 数量，并没有新邮箱的 commit，这就是 Github 上不显示 contribute 的原因。\n所以我们需要逐个仓库进行修改之前提交的 commit (的邮箱和用户名)。\n你想恢复几个仓库的 contribute，就重复几次下面的步骤。\n2. 将要修改的repo克隆到本地 # git clone --bare \u0026lt;the repo address\u0026gt; git \u0026ndash;bare 命令，用于克隆一个裸仓库（bare repository）。裸仓库是一种特殊的 Git 仓库，它只包含 Git 的版本控制数据，而不包含工作目录中的文件。\n3. 将命令行的当前目录切换到新克隆的库下 # cd \u0026lt;the repo path\u0026gt; 4. 编写脚本 # 根据你的信息修改以下变量，运行脚本。\n#!/bin/sh git filter-branch --env-filter \u0026#39; OLD_EMAIL=\u0026#34;需要被替换的邮箱\u0026#34; NEW_NAME=\u0026#34;新的用户名\u0026#34; NEW_EMAIL=\u0026#34;新的邮箱\u0026#34; if [ \u0026#34;$GIT_COMMITTER_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_COMMITTER_NAME=\u0026#34;$NEW_NAME\u0026#34; export GIT_COMMITTER_EMAIL=\u0026#34;$NEW_EMAIL\u0026#34; fi if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_AUTHOR_NAME=\u0026#34;$NEW_NAME\u0026#34; export GIT_AUTHOR_EMAIL=\u0026#34;$NEW_EMAIL\u0026#34; fi \u0026#39; --tag-name-filter cat -- --branches --tags 5. 再次查看查本地仓库（bare repo）中的提交： # 重复 第1步\ngit shortlog -s -e 此时应该能看到，之前的邮箱和用户名，已经被改为了新的邮箱和用户名。\n6. 把正确历史push到Github上 # 把修改好的本地历史信息 push 到 Github 上，之后就可以在网站上看到丢失的 Contribution 信息 😉。\ngit push --force --tags origin \u0026#39;refs/heads/*\u0026#39; git push：将本地的提交推送到远程仓库。\nforce 或 -f：强制推送。使用此选项会覆盖远程仓库中的历史记录，无论远程仓库的状态如何。这通常用于重写远程分支的历史，比如在你使用 git rebase 或 git filter-branch 之后。需要小心使用，以免覆盖他人的工作。\ntags：推送本地所有的标签到远程仓库。标签是对特定提交的引用，通常用于标记版本。\norigin：远程仓库的名称。默认情况下，origin 是克隆仓库时 Git 自动赋予远程仓库的名称。\n\u0026lsquo;refs/heads/\u0026rsquo;：表示本地的所有分支。refs/heads/ 是 Git 中保存分支的引用路径， 是通配符，表示所有分支。\n额外问题 # 此时已经解决了修改邮箱之后，历史 commit 丢失的问题。\n但是当在我之前本地的仓库中（非刚才 clone 的 bare 仓库），输入 git log，发现还是之前的 commit 信息 🙃。\n其实就是因为没有更新到远程仓库的信息。\n此时可以选择\ngit pull origin master --allow-unrelated-histories 会有冲突，解决冲突。\n或者选择更简单的方法 【比较推荐】：\n重置本地仓库\n强制拉取远程仓库的最新历史\n确定本地的更改已经保存！ git fetch origin git reset --hard origin/main 此时本地仓库的历史提交信息也更新了 🥰\n参考资料 # GitHub 修改 Commit 用户名和邮箱\n解决Github的Contribution没有增加的问题\n","date":"2024-06-29","externalUrl":null,"permalink":"/blog/github-%E9%82%AE%E7%AE%B1%E6%9B%B4%E6%94%B9%E4%B9%8B%E5%90%8E/","section":"归档","summary":"","title":"Github 邮箱更改之后","type":"blog"},{"content":"","date":"2024-06-29","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-06-29","externalUrl":null,"permalink":"/blog/","section":"归档","summary":"","title":"归档","type":"blog"},{"content":"","date":"2024-06-29","externalUrl":null,"permalink":"/tags/%E6%8A%80%E6%9C%AF/","section":"Tags","summary":"","title":"技术","type":"tags"},{"content":" 如果直接想看操作，请看 pr-九步 引言 # Working on [freenode] helped me earn many of the skills I later used for my studies in university and my actual job. I think working on open source projects helps me as much as it helps the project!\n— @errietta, \u0026ldquo;Why I love contributing to open source software\u0026rdquo;\n首先尝试开源之前，强烈推荐阅读 Open Source Guides (附有多种语言)，下文很多做法也是借鉴于这个手册。\n另外非常推荐尝试下面这个 first-contributions 这个项目进行提交，下文也会以这个项目为例，进行一次 contribution 的提交。\nfirstcontributions/first-contributions 🚀✨ Help beginners to contribute to open source projects null 43568 75478 那么就让我们开始吧！🚀\nContribute 前的准备工作 # 在某一个开源项目扎根多年，这意味着你只是对这一个开源项目无比的熟悉。若是切换到不同的项目，可能会发现完全是另外一回事，所谓的使用词汇、习惯用语、沟通方式都发生了变化。\n所以先不要着急提交，先了解一个项目。\n在准备贡献之前，如果你有一个好的想法，做一些快速的检查项（issue、pr），以确保没有人讨论过你的想法。\n如果没有人提这个 issue，先创建一个 issue： 报告你自己无法解决的错误 讨论一个高级主题或想法(例如. 社区、远景、政策等) 期望实现某新的特性，或者其它项目的想法 如果刚好有一个开放的 issue，和你不谋而合： 添加评论，告诉他人你将负责这个。这样的话，可以避免他人重复劳动。 如果说某个 issue 已经开放很久了， 这可能是已经有人正在解决中，又或者是早已经解决过了，所以也请添加评论，在打算开启工作之前，最好是确认一下。 如果你创建了一个 issue，但是没多久自己解决了， 也要添加评论，让其他人知道，然后关闭该 issue。记录本身就是为社区的贡献。 Contribute 步骤 # 下面会以 first-contributions 这个项目为例，进行提交。\n1. Fork（复制）远程代码仓库 # 点击图示中的按钮去 Fork 这个代码仓库。 这个操作会将代码仓库复制到你的账户名下。\n2. Clone（克隆）代码仓库到本地 # 使用 git clone 命令将 fork 的代码仓库克隆到本地，\n进入到本地仓库的目录。\ngit clone \u0026#34;your fork repo\u0026#34; cd \u0026#34;your fork repo\u0026#34; 3. 💥💥【关于同步】（理论内容，但是很重要！）💥💥 # 冲突一定要在本地搞定之后再推送！ 首先，我们有 3 个不同的存储库：在 Github 上的公共存储库 github.com/firstcontributions/first-contributions.git、在 GitHub 上对该存储库的 fork github.com/Your-Name/first-contributions/ 以及 本地计算机存储库。这种合作对于开源项目来说是典型的，称为 Triangle Workflows。\n为了使你的两个 repo 与远端的公共存储库保持同步，首先必须获取公共存储库并将其与您本地计算机的存储库合并。我们的第二步是将您的本地存储库推送到您的 GitHub fork。之后，从你的 fork 请求 “pull request”。\n在操作中注意以下几个原则：\n对别人的项目贡献PR，要用自己的 feature-branch。 每次准备 coding 之前保证自己的本地的 main-branch 是已经同步上游仓库的（目的是使新建的 feature-branch 是最新的）。 自己的 fork repo 的 main-branch 不一定要是最新的，一般都是落后上游并从不更新（因为每次更新和 push 都是用 feature-branch）。 每次修改完 feature-branch，要再次同步上游仓库，保证之后的 pr 没有冲突（降低冲突概率，也可能会有）。 所以可以看出为了避免 conflict（将 conflict 处理于本地），整个提交 pr 的过程中会涉及两次同步。\n第一次是准备 coding 之前（新建 featur-branch 之前），保证 main/feature branch 同步（这次可以采用git reset --hard origin/master，强制同步，下文会讲）。 第二次是准备 push 之前, 保证 feature-branch 同步（这次采用 git merge, 处理conflict）。 所以一直在保持同步上游仓库的分支，理论上只有 featur-branch，而 main-branch 只有在下次要提交新的 pr 之前再同步（当然，你也可以在对方接受了 pr 之后，找个时间同步一下 main-branch，什么时候都好。）\n如果想了解同步的更多方式，可以查阅 ：\nGithub进行fork后如何与原仓库同步：重新fork很省事，但不如反复练习版本合并 #67\n（更多是借鉴于 frostming大佬的做法） 如何参与Tianchi(天池)项目以及如何贡献代码 4. 在本地的仓库配置”上游”为远端仓库 # 执行命令 git remote 查看你的远程仓库的路径:\ngit remote -v 你可以查看当前本地仓库中已经配置的远程仓库地址。通常，你会看到 origin 对应的是你 fork 的仓库。\n如果只有上面2行，说明你未设置 upstream （中文叫：上游代码库）。一般情况下，设置好一次 upstream 后就无需重复设置。\n此时你应该是在你的 main-branch，如果不放心可以使用 git branch, 查看当前命令。\n执行命令 git remote add upstream 把远端的仓库设置为你的 upstream 。这个命令执行后，没有任何返回信息；所以再次执行命令 git remote -v 检查是否成功。\n$ git remote add upstream https://github.com/firstcontributions/first-contributions 执行后显示：\n5. 同步本地的仓库与上游仓库（第一次同步） # 切记，这步一定要在本地的 main-branch 分支执行，如果不确定，就使用 git branch 查看当前分支， 使用 git checkout main 切换到 main-branch。\n获取上游仓库的最新更改： git fetch upstream 该命令从上游仓库（upstream）获取所有分支和最新的提交，但不会自动合并或修改本地分支。\n重置（强制同步）本地 main-branch： git reset --hard upstream/main Q：上游的主分支是 upstream/main 还是 upstream/master？\nA：由于历史原因，2020年，为了消除术语中的潜在歧视性含义，Git 项目和许多开源社区决定将默认主分支名称从 master 改为 main。\n所以在使用 git reset --hard 之前可以先使用 git branch -r 查看上游所有分支，查看 upstream 的默认主分支是 main 还是 master。\n在执行 git reset \u0026ndash;hard upstream/main 命令之前，请确保已经将所有重要的更改提交到其他分支或保存到其他地方，因为此命令会丢弃本地 main 分支上的所有未提交的更改。 5. 新建分支 # 新建一个新的分支，在新的分支上进行开发，确保 main 分支保持同步且不受干扰。这使得 main 分支可以随时用于同步最新的上游代码。\n新建分支并且切换到新分支：\ngit branch add-myname git checkout add-myname 或者直接使用：\ngit checkout -b add-myname 新建分支名字时，确保清晰、易于理解，区分 issue 和 feature。例如：\nfeature/add-user-authentication\nfix/issue-1234-bug-fix\nupdate/readme-improvements\nhotfix/production-bug-fix\n6. 对代码进行修改，然后 Commit (提交) 修改 # 此时代码修改的操作，都是在你新建的branch上进行。 在本文的例子中，\n打开 Contributors.md 这个文件，更新文件内容，将你的名字加上去，保存修改。git status 这命令会列出被改动的文件。接着 git add 这命令则可以添加你的改动。\n现在就可以使用 git commit 命令 commit 你的修改了。\ngit commit -m \u0026#34;Add \u0026lt;你的名字\u0026gt; to Contributors list\u0026#34; 将 \u0026lt;你的名字\u0026gt; 替换成你的名字\n之后就可以使用 git push 命令, 将新分支推送到 fork 仓库：\ngit push origin add-myname 现在你的 fork repo 应该就会有你已经提交的新分支和内容。\n你可以重复此步，来不断修改代码、推动代码到自己的 fork 仓库，根据不同情况，这个过程可能会持续很久，或者一次就好。\n如果你已经完成了修改，准备好进行 pr 了，那么往下看。\n（加油！就快完事了😀）\n7. pr 之前，再次同步本地的分支与上游仓库（第二次同步） # 因为你在修改代码的过程中，可能远程仓库已经有所更改。\n这步就是为了避免 pr 之后再解决 conflict 的问题，而是在提交之前，讲 conflict 解决在本地。\n此时代码修改的操作，仍然在你新建的 branch 上进行。 在 feature 分支上直接从上游仓库获取最新的更新： git fetch upstream 将上游仓库的最新更改合并到 feature 分支： git merge upstream/main 解决冲突（如果有）： 如果在合并过程中遇到冲突，手动解决冲突。\n继续 merge： git merge --continue 8. 再次 Commit (提交) \u0026amp;\u0026amp; Push（推送） # 类似 第6步, 将分支代码 push 到 fork repo。\ngit add . git commit -m \u0026#34;new feature\u0026#34; git push origin add-myname 9. 提出 Pull Request 将你的修改供他人审阅 # 前往你的 Github 代码仓库，你会看到一个 Contribute 的按钮。点击该按钮，之后点击 OPen pull request。\n接着可以填写 Pull Request 表单，描述你的 pr，接着再点击 Create pull request 按钮，正式提交 pull request。\n之后便可以在远程仓库中看到你的 PR。\n而且能在里面看到你之前的 commit。\n当你提交了之后会发生什么 # 在你提交了贡献之后，下面几种情形是可能发生的：\n😭 没有人响应你。 # 即使在一个活跃的项目中，你的贡献也有可能得不到响应。\n如果过去了一周，依旧没有人响应，请心平气和的在后面跟帖，询求他人帮助你审核。如果你熟悉某个人可以审核你的贡献，你可以使用@+名字，直接提醒他一下。\n如果你做了所有该做的事情，还是没有人理你，那就是真的没有人对你的贡献做出响应。这可能令人难受，但是千万不要灰心，每个人都会遇到这样的情况。你没有得到回复的原因有很多，包括你无法控制的个人情况。再接再厉，试着寻找另一个项目或方式来做出贡献。\n🚧 有人要求你对自己的提交做出变更。 # 被要求修改你的提交是很常见的，无论是对你的想法的反馈，还是对你代码的改动。\n当有人提出变更时，请及时响应。他们花时间审核了你的提交，要尊重他们。开启 PR 然后一走了之是一种恶习。如果你不知道如何修改，请花时间深入研究，并在需要时寻求他人帮助。\n如果你没有时间继续处理这个 issue（举例来说，如果对话持续了几个月，而你情况有变），那么请告知维护者你无法再及时响应了。或许有其他人乐意接手你的工作\n👎 你的贡献没有被接受。 # 你的贡献最终可能被接受，也可能不被接受。真心希望你没有为此花费太多力气。如果你不确定为什么它不被接受，请维护者提供反馈和说明是完全合理的。但最终，无论如何，你都要对他们的决定表示尊重。不要去无谓的争论或者显露敌意。如果你坚持自己，你仍可以 fork 项目，按照自己的思路来发展分支。\n🎉 你的贡献被采纳。 # 太棒了！你已经成功地完成了一次开源贡献！\nPR 九步： # # Step 1: Fork（复制）远程代码仓库 # Step 2: Clone（克隆）代码仓库到本地 git clone https://github.com/your-name/fork-repo.git cd fork-repo # Step 3: 查看远程仓库路径确认添加成功 git remote -v # Step 4: 添加上游仓库作为 upstream git remote add upstream https://github.com/upstream-owner/original-repo.git git remote -v # Step 5: 同步本地主分支与上游主分支 git fetch upstream git reset --hard upstream/main # 或者 upstream/master # Step 6: 新建一个特性分支进行开发 git checkout -b feature-branch # 在 feature-branch 上做一些更改和提交 # Step 7: 再次同步本地分支与上游仓库的主分支 git checkout feature-branch git fetch upstream git merge upstream/main # 或者 upstream/master # Step 8: 将特性分支推送到你的 Fork 仓库 git add . git commit -m \u0026#34;new feature\u0026#34; git push origin feature-branch # Step 9: 在 GitHub 上创建 Pull Request # - 导航到你的 Fork 仓库页面，选择 feature-branch 分支 # - 点击 \u0026#34;Pull Request\u0026#34; 按钮，创建 PR 到 upstream 的主分支 # - 填写 PR 标题、描述，提交 PR # 请确保在每个步骤执行前理解并确认操作的正确性，特别是在涉及重置和合并的步骤中。 参考资料 # first-contributions\nhow-to-contribute-to-open-source\nOpen Source Guides\nHow To Get Started In Open Source\nGithub进行fork后如何与原仓库同步：重新fork很省事，但不如反复练习版本合并 #67\n如何参与Tianchi(天池)项目以及如何贡献代码\n","date":"2024-06-25","externalUrl":null,"permalink":"/blog/%E5%85%B3%E4%BA%8E-contribution-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","section":"归档","summary":"","title":"关于 Contribution 的那些事","type":"blog"},{"content":"","date":"2024-06-25","externalUrl":null,"permalink":"/tags/%E5%BC%80%E6%BA%90/","section":"Tags","summary":"","title":"开源","type":"tags"},{"content":"","date":"2024-06-23","externalUrl":null,"permalink":"/tags/remote-work/","section":"Tags","summary":"","title":"Remote Work","type":"tags"},{"content":" 1. 远程工作的一些平台 # 1. 求职平台（综合） # Linkedin —— 领英\nIndeed —— Indeed\nRemote OK —— 寻找一份在能在任何地方工作的远程工作\nWWR —— 寻找美妙的远程工作\nRemotive —— 轻松找到理想的远程工作\n2. 求职平台（Web3） # 3. 其他 # RW 社区 —— RW 是一个共创型的数字游民社区。同时也会提供一些远程工作机会\nHack News —— 由 Y Combinator 提供的一个技术新闻平台。同时也会提供一些工作信息\nremote-job —— Github上整理的远程公司列表\nawwsome-remote-job —— Github上很全的资料\n中文remote-job资源 —— Github上中文remote-job资源\nV2EX —— V2EX中文社区\n2. 技能点树 # 1. Web3 相关 # 智能合约（Solidity）\n智能合约开发经验（例如Foundry，HardHat等）\nSQL 和 BigQuery\nRust\n2. Python 相关 # Web 技术： # RestAPI\nGraphQL\nPostgres\nMongoDB\nRedis\nKafka\nAWS\nDjango\nAI 相关 # 云平台 S3、Lambda、API Gateway 等 AWS 服务和技术的经验\n容器 Docker\n数据库 MySQL/PostgreSQL/MongoDB/Redis\nCI/CD pipelines\n3. 工具相关 # VSCode\nGit版本控制\n容器化技术（Docker、Kubernetes）\n4. 语言相关 # Fluent in English, both written and spoken.\n5. 其他（for a perfect match） # S3、Lambda、API Gateway 等 AWS 服务和技术的经验\n前端开发经验(React.js经验)\n有从事开源项目/技术的经验\n","date":"2024-06-23","externalUrl":null,"permalink":"/blog/%E5%85%B3%E4%BA%8E%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","section":"归档","summary":"","title":"关于远程工作的那些事","type":"blog"},{"content":"","date":"2024-06-23","externalUrl":null,"permalink":"/tags/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/","section":"Tags","summary":"","title":"资料整理","type":"tags"},{"content":"","date":"2024-06-23","externalUrl":null,"permalink":"/tags/%E9%93%BE%E6%8E%A5/","section":"Tags","summary":"","title":"链接🔗","type":"tags"},{"content":" 这里面放一些有趣的技术文章链接\n🐍 Python # Python全栈开发从入门到入土\n","date":"2024-06-23","externalUrl":null,"permalink":"/blog/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0%E6%8A%80%E6%9C%AF%E7%AF%87/","section":"归档","summary":"","title":"一些有趣的文章（技术篇）","type":"blog"},{"content":"","date":"2024-06-23","externalUrl":null,"permalink":"/tags/%E8%BD%AC%E5%8F%91/","section":"Tags","summary":"","title":"转发","type":"tags"},{"content":"","date":"2024-06-15","externalUrl":null,"permalink":"/tags/github-action/","section":"Tags","summary":"","title":"Github Action","type":"tags"},{"content":" 1、什么是 Github Action ? # GitHub Actions 是 GitHub 提供的一项 持续集成和持续交付（CI/CD）服务，允许开发者在代码库上自动化各种任务。\n简单来说，你可以把 GitHub Actions 想象成在你的 GitHub 代码仓库里的一个机器人，并且可以根据你给它设定的规则，自动完成一系列任务（Workflow），主要目的就是服务于这个项目（代码仓库）。\n2、基本概念 # Workflow（工作流程）：定义了一系列要自动执行的过程。详情可以见 第三节。\nEvent（事件）：触发 Workflow 工作流的动作，例如 push、pull request、release 等。详情可见 官方文档。\nJob（任务）：一个 Workflow 由一个或多个 Jobs 构成，一次 Workflow 的运行，可以完成多个 Jobs。\nStep（步骤）：每个 Jobs 由多个 Step 构成，一步步完成。\nAction（动作）：每个 Step 可以依次执行一个或多个命令（Action）。\nevent(触发) -\u0026gt; workflow -\u0026gt; job -\u0026gt; step -\u0026gt; action\n3、例子：Github Page 静态博客自动发布 # 使用 Github Action 构建博客自动发布流程。\n之前手动发布静态的博客文件， 需要切换到 public/ 目录进行 push， 更新 Github page 界面\n是否可以在 push到 博客原文件仓库的时候，自动更新 Github Page（Blog）界面呢？\n1. 配置 workflow 文件 # GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的 .github/workflows 目录。\nworkflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为 .yml，比如 blog.yml。\n一个库可以有多个 workflow 文件。GitHub 只要发现 .github/workflows 目录里面有 .yml文件，就会自动运行该文件。\n自动发布示例配置如下：\nname: Automatic Blog Publishing on: push: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: publish: name: auto publish blog runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.AUTO_PUBLISH_BLOG_TOKEN }} EXTERNAL_REPOSITORY: LcenArthas/LcenArthas.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 下面针对上面的 workflow 配置文件，解释其中用到的字段。\nworkflow 文件字段非常多，详见 官方文档\n1. name 字段 # 是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。\nname: Automatic Blog Publishing 2. on 字段 # 指定触发 workflow 的条件，通常是某些事件。下面代码指定，push 事件触发 workflow。\n完整的事件列表，请查看 官方文档。\non.schedule 字段\n除了代码库事件，GitHub Actions 也支持定时运行。注意，时间是使用 POSIX cron 语法将工作流计划为在指定的 UTC 时间运行。\non: push: schedule: # Runs everyday at 8:00 AM (UTC 0:00 AM) - cron: \u0026#34;0 0 * * *\u0026#34; 3. job 字段 # workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。需要给出每一项任务的 job_id，具体名称自定义， 例如我们设置了一个 publish 任务。\njobs.\u0026lt;job_id\u0026gt;.name 字段\n是任务的说明，可以任意写。\njobs.\u0026lt;job_id\u0026gt;.runs-on 字段\n是指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机见 官方文档\njobs: publish: name: auto publish blog runs-on: ubuntu-latest 4. jobs.\u0026lt;job_id\u0026gt;.steps 字段 # 是指作业包含一系列任务，称为 steps。 步骤可以运行命令、运行设置任务，或者运行您的仓库、公共仓库中的操作或 Docker 注册表中发布的操作。\n每个 Job 可以包含一个或多个步骤。\njobs.\u0026lt;job_id\u0026gt;.steps.name字段\n是指步骤名称。\njobs.\u0026lt;job_id\u0026gt;.steps.uses 字段\n是指可以使用在与工作流、 官方actions、 官方actions市场或者 已发布的 Docker 容器映像相同的存储库中定义的操作。\njobs.\u0026lt;job_id\u0026gt;.steps.with 字段\n是指某些操作需要必须使用 with 关键字设置的输入。得看具体引用的工作流需要的参数。\n下面逐步分析每个步骤的作用\nsteps: - name: Checkout uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 上面是引用了 GitHub Action Checkout @v4版本 这个工作流。\n它通常是许多工作流的第一步，用于获取源码（将仓库的内容检出到运行工作流的虚拟机上，使得后续步骤可以访问和操作代码。）\nsubmodules：true，会检出子模块，即我们的主题模块。 fetch-depth: 0，指定检出的提交历史记录深度。默认是 1，即只检出最新的提交。设置为 0 表示完整检出所有历史记录。 例如：\n- name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; 上面是引用了 GitHub Action Hugo setup @v3版本 这个工作流。\n作用是安装指定版本的 Hugo 静态站点生成器。\n例如：\n- name: Build Web run: hugo 这一步骤执行了 hugo 命令，用于运行 Hugo 命令来构建网站。\n例如：\n- name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.AUTO_PUBLISH_BLOG_TOKEN }} EXTERNAL_REPOSITORY: LcenArthas/LcenArthas.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 上面是引用了 GitHub Action GitHub Pages action @v4版本 这个工作流。\n作用是用于将生成的静态网站部署到 GitHub Page。\nEXTERNAL_REPOSITORY: LcenArthas/LcenArthas.github.io，指定要将内容部署到的外部仓库。\nPERSONAL_TOKEN: ${{ secrets.AUTO_PUBLISH_BLOG_TOKEN }}，用于认证的 GitHub 个人访问令牌，通常通过 GitHub Secrets 管理。\ncommit_message: ${{ github.event.head_commit.message }}，使用触发工作流的提交信息作为部署的提交信息。这样可以保留提交历史的上下文信息。\nPUBLISH_BRANCH: main, 指定要推送到的目标分支，如果不想新建分支，指定 Github Page 的主分支（main/master）\n5. 如何创建 secrets.AUTO_PUBLISH_BLOG_TOKEN # 要在 GitHub 账户下 Setting - Developer setting - Personal access tokens 下创建一个 Token。权限需要开启 repo 与 workflow。 配置后复制生成的 Token（注：只会出现一次, 推荐另存一个地方） Make sure to copy your personal access token now. You won’t be able to see it again! 然后在我们博客源仓库的 Settings - Secrets - Actions 中添加 Token， 粘贴在 Secret 中，Name 随便起一个，但是注意要和 PERSONAL_TOKEN: ${{ secrets.AUTO_PUBLISH_BLOG_TOKEN }} 后面的AUTO_PUBLISH_BLOG_TOKEN 一致，这样 GitHub Action 就可以获取到 Token 了。\n完成上述配置后，推送代码至仓库，即可触发 GitHub Action，自动生成博客页面并推送至 GitHub Pages 仓库。 2. 推送本地博客代码至仓库 # 完成上述配置后，推送代码至仓库，即可触发 GitHub Action，自动生成博客页面并推送至 GitHub Pages 仓库。\n可以在仓库的 Actions - All workflows 中看到运行状态和logs。\n参考资料 # [1]. 阮一峰GitHub Actions 入门教程\n[2]. GitHub Actions 官方文档\n[3]. Hugo + GitHub Action，搭建你的博客自动发布系统\n","date":"2024-06-15","externalUrl":null,"permalink":"/blog/github-action-+-%E5%9F%BA%E4%BA%8E-github-page-blog-%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/","section":"归档","summary":"","title":"Github Action + 基于 Github Page Blog 自动发布","type":"blog"},{"content":" About Me # 程序员，阅读者，人间观察者，快乐NPC About Site # 本站生日：2024-06-02 ","date":"2024-06-02","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"About","type":"page"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/movienote/","section":"电影","summary":"","title":"电影","type":"movienote"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/booknote/","section":"读书","summary":"","title":"读书","type":"booknote"}]